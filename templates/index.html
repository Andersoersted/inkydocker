{% extends "base.html" %}
{% block title %}Gallery - InkyDocker{% endblock %}

{% block content %}
<div class="container py-4">
  <!-- Main Content: Two Columns -->
  <div class="row">
    <!-- Left Column (narrower) -->
    <div class="col-md-3 mb-4">
      <!-- Current Image Section -->
      <div class="card mb-4 shadow-sm">
        <div class="card-header bg-light">
          <h2 class="h4 mb-0" id="currentImageTitle">Current image on {{ devices[0].friendly_name if devices else 'N/A' }}</h2>
        </div>
        <div class="card-body text-center">
          <div class="current-image-container">
            {% if devices and devices[0].last_sent %}
              {% set is_screenshot = devices[0].last_sent in screenshots_filenames %}
              {% if is_screenshot %}
                <img
                  id="currentImage"
                  src="{{ url_for('browserless.get_screenshot', filename=devices[0].last_sent, cropped='true') }}"
                  alt="Current Image"
                  class="img-fluid rounded"
                  style="max-height: 300px; max-width: 100%; object-fit: contain;"
                  loading="lazy"
                >
              {% else %}
                <img
                  id="currentImage"
                  src="{{ url_for('image.uploaded_file', filename=devices[0].last_sent) }}"
                  alt="Current Image"
                  class="img-fluid rounded"
                  style="max-height: 300px; max-width: 100%; object-fit: contain;"
                  loading="lazy"
                >
              {% endif %}
            {% else %}
              <p id="currentImagePlaceholder" class="text-muted">No image available.</p>
            {% endif %}
          </div>
          {% if devices|length > 1 %}
            <div class="mt-3">
              <button id="prevDevice" class="btn btn-outline-primary">&larr;</button>
              <button id="nextDevice" class="btn btn-outline-primary">&rarr;</button>
            </div>
          {% endif %}
        </div>
      </div>

      <!-- Status messages will be shown below the upload button -->
      <div class="card mb-4 shadow-sm">
        <div class="card-header bg-light">
          <h2 class="h5 mb-0">Select eInk Display</h2>
        </div>
        <div class="card-body">
          {% if devices %}
            <div class="device-options">
              {% for device in devices %}
                <div class="form-check mb-2">
                  <input
                    class="form-check-input"
                    type="radio"
                    name="device"
                    id="device{{ loop.index }}"
                    value="{{ device.address }}"
                    data-index="{{ loop.index0 }}"
                    data-friendly="{{ device.friendly_name }}"
                    data-resolution="{{ device.resolution }}"
                    data-orientation="{{ device.orientation|lower }}"
                    {% if loop.first %}checked{% endif %}
                  >
                  <label class="form-check-label" for="device{{ loop.index }}">
                    {{ device.friendly_name }}
                  </label>
                </div>
              {% endfor %}
            </div>
          {% else %}
            <p class="text-danger">No devices configured. Go to <a href="{{ url_for('settings.settings') }}">Settings</a>.</p>
          {% endif %}
        </div>
      </div>

      <div class="card shadow-sm">
        <div class="card-header bg-light">
          <h2 class="h5 mb-0">Upload Images</h2>
        </div>
        <div class="card-body">
          <form id="uploadForm" method="post" enctype="multipart/form-data" action="{{ url_for('image.upload_file') }}">
            <div class="mb-3">
              <input class="form-control" type="file" name="file" multiple id="fileInput" required>
            </div>
            <button type="submit" class="btn btn-primary">Upload</button>
            <div class="progress mt-3" id="progressContainer" style="display: none;">
              <div class="progress-bar" id="progressBar" role="progressbar" style="width: 0%; height: 24px; line-height: 24px;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="uploadStatus" class="mt-2"></div>
          </form>
        </div>
      </div>
    </div>

    <!-- Right Column: Gallery (wider) -->
    <div class="col-md-9">
      <div class="card shadow-sm">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
          <h2 class="h5 mb-0">Gallery</h2>
        </div>
        <div class="card-body">
          <div class="mb-3">
            <input type="text" class="form-control" id="gallerySearch" placeholder="Search images by tags...">
          </div>
          <div id="searchSpinner" class="text-center my-3" style="display:none;">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
          <div class="gallery" id="gallery">
            <!-- Gallery items will be loaded here -->
          </div>
          <div id="loadingSpinner" class="text-center my-3" style="display:none;">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
          <div class="text-center mt-3">
            <button id="loadMoreBtn" class="btn btn-outline-primary">Load More</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap 5 Info Modal -->
<div class="modal fade" id="infoModal" tabindex="-1" aria-labelledby="infoModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="infoModalLabel">Image Info</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="closeInfoModal()"></button>
      </div>
      <div class="modal-body">
        <div class="text-center mb-4">
          <img id="infoImagePreview" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3 2'%3E%3C/svg%3E" data-src="" alt="Info Preview" class="img-fluid rounded lazy" loading="lazy" style="max-height: 300px;">
          <div class="mt-3">
            <button type="button" class="btn btn-outline-primary" onclick="openCropModal()">Crop Image</button>
          </div>
        </div>
        <div class="row">
          <!-- Left Column: Basic Info -->
          <div class="col-md-6" id="infoLeftColumn">
            <p><strong>Filename:</strong> <span id="infoFilename">N/A</span></p>
            <p><strong>Resolution:</strong> <span id="infoResolution">N/A</span></p>
            <p><strong>Filesize:</strong> <span id="infoFilesize">N/A</span></p>
          </div>
          <!-- Right Column: Editable Tags & Favorite -->
          <div class="col-md-6">
            <div class="mb-3">
              <label class="form-label"><strong>Tags:</strong></label>
              <div id="tagContainer" class="mb-2" style="max-height: 200px; overflow-y: auto; display: flex; flex-wrap: wrap;"></div>
              <div class="input-group mt-2">
                <input type="text" class="form-control" id="newTagInput" placeholder="Add a new tag...">
                <button class="btn btn-outline-secondary" type="button" onclick="addTag()">Add</button>
              </div>
              <input type="hidden" id="infoTags">
            </div>
            <div class="mb-3 form-check">
              <input type="checkbox" class="form-check-input" id="infoFavorite">
              <label class="form-check-label" for="infoFavorite"><strong>Favorite</strong></label>
            </div>
            <div id="infoStatus" class="text-success mb-3"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="closeInfoModal()">Close</button>
        <button type="button" class="btn btn-primary" onclick="saveInfoEdits()">Save</button>
        <button type="button" class="btn btn-outline-secondary" onclick="runOpenClip()">Re-run Tagging</button>
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap 5 Lightbox Modal -->
<div class="modal fade" id="lightboxModal" tabindex="-1" aria-labelledby="lightboxModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content bg-dark text-white">
      <div class="modal-header border-0">
        <h5 class="modal-title" id="lightboxCaption"></h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close" onclick="closeLightbox()"></button>
      </div>
      <div class="modal-body d-flex align-items-center justify-content-center">
        <img class="img-fluid lazy" id="lightboxImage" loading="lazy" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3 2'%3E%3C/svg%3E" data-src="" alt="Enlarged Image">
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap 5 Crop Modal -->
<div class="modal fade" id="cropModal" tabindex="-1" aria-labelledby="cropModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="cropModalLabel">Crop Image</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" onclick="closeCropModal()"></button>
      </div>
      <div class="modal-body">
        <div class="crop-container-wrapper" style="position: relative; height: 70vh; border: 2px solid #ddd; border-radius: 5px; overflow: hidden;">
          <div id="cropContainer" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow-y: auto; max-height: 70vh;">
            <img id="cropImage" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3 2'%3E%3C/svg%3E" data-src="" alt="Crop Image" class="img-fluid w-100 lazy" loading="lazy">
          </div>
          <div style="position: absolute; top: 10px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;">
            <i class="fas fa-arrows-alt-v"></i> Scroll to view full image
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="closeCropModal()">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="saveCropData()">Save Crop</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block head %}
{{ super() }}
<script src="{{ url_for('static', filename='gallery.js') }}" defer></script>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener("DOMContentLoaded", function() {
  // Inject dynamic CSS for favorite icon
  const styleTag = document.createElement('style');
  styleTag.innerHTML = `
    .favorite-icon i {
      font-size: 1.5em;
      color: #ccc;
      transition: color 0.3s;
    }
    .favorite-icon.favorited i {
      color: red;
    }
  `;
  document.head.appendChild(styleTag);
});

/* Lightbox functions with Bootstrap 5 */
function openLightbox(src, alt) {
  const lightboxModal = new bootstrap.Modal(document.getElementById('lightboxModal'));
  const lightboxImage = document.getElementById('lightboxImage');
  const lightboxCaption = document.getElementById('lightboxCaption');
  lightboxImage.dataset.src = src;
  lightboxImage.src = src; // Also set src directly for immediate display
  lightboxImage.classList.remove('lazy');
  lightboxCaption.innerText = alt;
  lightboxModal.show();
}
function closeLightbox() {
  const lightboxModalEl = document.getElementById('lightboxModal');
  const lightboxModal = bootstrap.Modal.getInstance(lightboxModalEl);
  if (lightboxModal) {
    lightboxModal.hide();
  }
}

/* Debounce helper */
function debounce(func, wait) {
  let timeout;
  return function() {
    var context = this;
    var args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      func.apply(context, args);
    }, wait);
  };
}

/* Gallery pagination and search */
const searchInput = document.getElementById('gallerySearch');
const searchSpinner = document.getElementById('searchSpinner');
const loadingSpinner = document.getElementById('loadingSpinner');
const gallery = document.getElementById('gallery');
const loadMoreBtn = document.getElementById('loadMoreBtn');

let currentPage = 1;
const imagesPerPage = 20;
let isSearchMode = false;
let searchQuery = '';
let allImages = [];

// Function to create gallery item HTML
function createGalleryItemHTML(image) {
  // Extract tags for filtering
  const tags = image.tags ? image.tags.join(', ') : '';
  
  // Add query parameter to indicate this is for gallery display
  const galleryUrl = `${image.url}?for=gallery`;
  
  return `
    <div class="gallery-item" data-tags="${tags}">
      <div class="img-container">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 200' width='300' height='200'%3E%3Crect width='300' height='200' fill='%23f8f9fa'/%3E%3Cpath d='M145,80 L155,80 L155,120 L145,120 Z' fill='%23dee2e6'/%3E%3Ccircle cx='150' cy='60' r='10' fill='%23dee2e6'/%3E%3Cpath d='M130,140 L170,140 L170,150 L130,150 Z' fill='%23dee2e6'/%3E%3C/svg%3E" data-src="${galleryUrl}" alt="${image.filename}" data-filename="${image.filename}" loading="lazy" class="lazy">
        <div class="overlay">
          <div class="favorite-icon ${image.favorite ? 'favorited' : ''}" title="Favorite" data-image="${image.filename}">
            <i class="fa fa-heart"></i>
          </div>
          <button class="send-button" data-image="${image.filename}">Send</button>
          <button class="info-button" data-image="${image.filename}">Info</button>
          <div class="delete-icon" title="Delete" data-image="${image.filename}">
            <i class="fa fa-trash"></i>
          </div>
        </div>
      </div>
    </div>
  `;
}

// Function to load images
function loadImages(page = 1, append = false) {
  if (!append) {
    gallery.innerHTML = '';
  }
  
  loadingSpinner.style.display = 'block';
  
  const url = isSearchMode
    ? `/api/search_images?q=${encodeURIComponent(searchQuery)}&page=${page}&per_page=${imagesPerPage}`
    : `/api/get_images?page=${page}&per_page=${imagesPerPage}`;
  
  fetch(url)
    .then(function(response) {
      return response.json();
    })
    .then(function(data) {
      loadingSpinner.style.display = 'none';
      
      if (data.status === "success") {
        const images = isSearchMode ? data.results.ids : data.images;
        
        if (images.length === 0 && page === 1) {
          gallery.innerHTML = "<p>No images found.</p>";
          loadMoreBtn.style.display = 'none';
          return;
        }
        
        if (images.length < imagesPerPage) {
          loadMoreBtn.style.display = 'none';
        } else {
          loadMoreBtn.style.display = 'block';
        }
        
        images.forEach(function(image) {
          const imageData = {
            filename: isSearchMode ? image : image.filename,
            url: `/images/${encodeURIComponent(isSearchMode ? image : image.filename)}`,
            favorite: isSearchMode ? false : image.favorite,
            tags: isSearchMode ? [] : (image.tags || [])
          };
          
          const itemHTML = createGalleryItemHTML(imageData);
          gallery.insertAdjacentHTML('beforeend', itemHTML);
        });
        
        // Initialize masonry layout after adding items
        if (typeof initMasonryLayout === 'function') {
          setTimeout(initMasonryLayout, 100);
        }
        
        // Initialize lazy loading for the new images
        if (typeof initLazyLoading === 'function') {
          setTimeout(initLazyLoading, 200);
        } else {
          // Fallback if the global function isn't available
          if ('IntersectionObserver' in window) {
            const lazyImageObserver = new IntersectionObserver((entries, observer) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  const lazyImage = entry.target;
                  if (lazyImage.dataset.src) {
                    // Set up the onload handler before changing src
                    lazyImage.onload = function() {
                      // Add loaded class for fade-in effect
                      lazyImage.classList.add('loaded');
                      // Add fade-in class for additional animation
                      lazyImage.classList.add('fade-in');
                      // Remove the onload handler to prevent memory leaks
                      this.onload = null;
                    };
                    
                    // Set the src to trigger loading
                    lazyImage.src = lazyImage.dataset.src;
                    lazyImageObserver.unobserve(lazyImage);
                  }
                }
              });
            });
            
            // Observe all newly added lazy images
            gallery.querySelectorAll('img.lazy').forEach(lazyImage => {
              lazyImageObserver.observe(lazyImage);
            });
          } else {
            // Fallback for browsers that don't support IntersectionObserver
            gallery.querySelectorAll('img.lazy').forEach(img => {
              if (img.dataset.src) {
                // Set up the onload handler before changing src
                img.onload = function() {
                  // Add loaded class for fade-in effect
                  img.classList.add('loaded');
                  // Add fade-in class for additional animation
                  img.classList.add('fade-in');
                  // Remove the onload handler to prevent memory leaks
                  this.onload = null;
                };
                
                // Set the src to trigger loading
                img.src = img.dataset.src;
              }
            });
          }
        }
      } else {
        console.error("Error loading images:", data.message);
      }
    })
    .catch(function(err) {
      loadingSpinner.style.display = 'none';
      console.error("Error loading images:", err);
    });
}

// Load initial images
document.addEventListener('DOMContentLoaded', function() {
  loadImages(1);
});

// Load more images when button is clicked
if (loadMoreBtn) {
  loadMoreBtn.addEventListener('click', function() {
    currentPage++;
    loadImages(currentPage, true);
  });
}

// Search functionality
const performSearch = debounce(function() {
  searchQuery = searchInput.value.trim();
  
  if (!searchQuery) {
    isSearchMode = false;
    currentPage = 1;
    loadImages(1);
    return;
  }
  
  isSearchMode = true;
  currentPage = 1;
  searchSpinner.style.display = 'block';
  
  loadImages(1);
  searchSpinner.style.display = 'none';
}, 500);

if (searchInput) {
  searchInput.addEventListener('input', performSearch);
}

/* Upload form */
const uploadForm = document.getElementById('uploadForm');
uploadForm.addEventListener('submit', function(e) {
  e.preventDefault();
  const fileInput = document.getElementById('fileInput');
  if (!fileInput.files.length) return;
  
  const formData = new FormData();
  for (let i = 0; i < fileInput.files.length; i++) {
    formData.append('file', fileInput.files[i]);
  }
  
  const selectedDevice = document.querySelector('input[name="device"]:checked');
  const deviceFriendly = selectedDevice ? selectedDevice.getAttribute('data-friendly') : "unknown display";
  
  const xhr = new XMLHttpRequest();
  xhr.open('POST', uploadForm.action, true);

  xhr.upload.addEventListener("progress", function(e) {
    if (e.lengthComputable) {
      const percentComplete = (e.loaded / e.total) * 100;
      const progressBar = document.getElementById('progressBar');
      progressBar.style.width = percentComplete + '%';
      progressBar.textContent = Math.round(percentComplete) + '%';
      document.getElementById('progressContainer').style.display = 'block';
    }
  });

  xhr.onload = function() {
    if (xhr.status === 200) {
      document.getElementById('uploadStatus').textContent = 'Image uploaded successfully!';
      // Instead of reloading the page, refresh the gallery
      setTimeout(function() {
        currentPage = 1;
        loadImages(1);
        document.getElementById('uploadStatus').textContent = '';
        document.getElementById('progressContainer').style.display = 'none';
      }, 1500);
    } else {
      document.getElementById('uploadStatus').textContent = 'Error uploading image.';
    }
  };

  xhr.onerror = function() {
    document.getElementById('uploadStatus').textContent = 'Error uploading image.';
  };

  xhr.send(formData);
});

/* Send image with spinner and in-page notification */
document.addEventListener('click', function(e) {
  if (e.target && e.target.classList.contains('send-button')) {
    e.stopPropagation();
    const button = e.target;
    const originalText = button.textContent;
    const imageFilename = button.getAttribute('data-image');
    const selectedDevice = document.querySelector('input[name="device"]:checked');
    if (!selectedDevice) return;
    
    // Create or get status container
    let statusContainer = document.getElementById('sendStatusContainer');
    if (!statusContainer) {
      statusContainer = document.createElement('div');
      statusContainer.id = 'sendStatusContainer';
      statusContainer.className = 'position-fixed bottom-0 end-0 p-3';
      statusContainer.style.zIndex = '1050';
      document.body.appendChild(statusContainer);
    }
    
    // Show spinner in button
    button.disabled = true;
    button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Sending...';
    
    const deviceFriendly = selectedDevice.getAttribute('data-friendly');
    const formData = new FormData();
    formData.append("device", selectedDevice.value);
    formData.append("filename", imageFilename);

    // Use the base send_image endpoint without the filename in the URL
    const baseUrl = "/send_image";
    
    // Add a timestamp to prevent caching issues
    const timestamp = new Date().getTime();
    const finalUrl = `${baseUrl}?t=${timestamp}`;
    
    // Log the request details to console for debugging
    console.log(`Sending image: ${imageFilename} to device: ${deviceFriendly} (${selectedDevice.value})`);
    console.log(`Request URL: ${finalUrl}`);
    
    // Send the request with a timeout
    const xhr = new XMLHttpRequest();
    xhr.open('POST', finalUrl, true);
    xhr.timeout = 120000; // 120 second timeout (matching server-side timeout)
    
    // Add event listeners for all possible outcomes
    xhr.onload = function() {
      // Re-enable button
      button.disabled = false;
      
      console.log(`Response received: Status ${xhr.status}, Text: ${xhr.responseText}`);
      
      if (xhr.status === 200) {
        // Show success icon in button temporarily
        button.innerHTML = '<i class="fas fa-check"></i> Sent!';
        
        // Create toast notification
        const toastEl = document.createElement('div');
        toastEl.className = 'toast align-items-center text-white bg-success border-0';
        toastEl.setAttribute('role', 'alert');
        toastEl.setAttribute('aria-live', 'assertive');
        toastEl.setAttribute('aria-atomic', 'true');
        toastEl.innerHTML = `
          <div class="d-flex">
            <div class="toast-body">
              <i class="fas fa-check-circle me-2"></i> Image sent successfully to ${deviceFriendly}!
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
        `;
        statusContainer.appendChild(toastEl);
        
        // Initialize and show the toast
        const toast = new bootstrap.Toast(toastEl, {
          autohide: true,
          delay: 3000
        });
        toast.show();
        
        // Remove the toast element when hidden
        toastEl.addEventListener('hidden.bs.toast', function() {
          toastEl.remove();
        });
        
        // Update the current image display without reloading
        setTimeout(function() {
          updateCurrentImageDisplay();
          // Restore original button text
          button.innerHTML = originalText;
        }, 2000);
      } else {
        // Show error in button
        button.innerHTML = '<i class="fas fa-times"></i> Failed';
        
        // Create toast notification for error
        const toastEl = document.createElement('div');
        toastEl.className = 'toast align-items-center text-white bg-danger border-0';
        toastEl.setAttribute('role', 'alert');
        toastEl.setAttribute('aria-live', 'assertive');
        toastEl.setAttribute('aria-atomic', 'true');
        toastEl.innerHTML = `
          <div class="d-flex">
            <div class="toast-body">
              <i class="fas fa-exclamation-circle me-2"></i> Error sending image.
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
        `;
        statusContainer.appendChild(toastEl);
        
        // Initialize and show the toast
        const toast = new bootstrap.Toast(toastEl, {
          autohide: true,
          delay: 5000
        });
        toast.show();
        
        // Remove the toast element when hidden
        toastEl.addEventListener('hidden.bs.toast', function() {
          toastEl.remove();
        });
        
        // Restore original button text after delay
        setTimeout(function() {
          button.innerHTML = originalText;
        }, 2000);
      }
    };

    // Handle network errors
    xhr.onerror = function() {
      console.error("Network error occurred while sending image");
      // Re-enable button and show error
      button.disabled = false;
      button.innerHTML = '<i class="fas fa-times"></i> Failed';
      
      // Create toast notification for network error
      const toastEl = document.createElement('div');
      toastEl.className = 'toast align-items-center text-white bg-danger border-0';
      toastEl.setAttribute('role', 'alert');
      toastEl.setAttribute('aria-live', 'assertive');
      toastEl.setAttribute('aria-atomic', 'true');
      toastEl.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">
            <i class="fas fa-exclamation-circle me-2"></i> Network error while sending image.
          </div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      `;
      statusContainer.appendChild(toastEl);
      
      // Initialize and show the toast
      const toast = new bootstrap.Toast(toastEl, {
        autohide: true,
        delay: 5000
      });
      toast.show();
      
      // Remove the toast element when hidden
      toastEl.addEventListener('hidden.bs.toast', function() {
        toastEl.remove();
      });
      
      // Restore original button text after delay
      setTimeout(function() {
        button.innerHTML = originalText;
      }, 2000);
    };
    
    // Handle timeout errors
    xhr.ontimeout = function() {
      console.error("Request timed out while sending image");
      // Re-enable button and show error
      button.disabled = false;
      button.innerHTML = '<i class="fas fa-times"></i> Timeout';
      
      // Create toast notification for timeout error
      const toastEl = document.createElement('div');
      toastEl.className = 'toast align-items-center text-white bg-warning border-0';
      toastEl.setAttribute('role', 'alert');
      toastEl.setAttribute('aria-live', 'assertive');
      toastEl.setAttribute('aria-atomic', 'true');
      toastEl.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">
            <i class="fas fa-clock me-2"></i> Request timed out while sending image. The eInk display might be busy.
          </div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      `;
      statusContainer.appendChild(toastEl);
      
      // Initialize and show the toast
      const toast = new bootstrap.Toast(toastEl, {
        autohide: true,
        delay: 5000
      });
      toast.show();
      
      // Remove the toast element when hidden
      toastEl.addEventListener('hidden.bs.toast', function() {
        toastEl.remove();
      });
      
      // Restore original button text after delay
      setTimeout(function() {
        button.innerHTML = originalText;
      }, 2000);
    };

    xhr.send(formData);
  }
});

/* Delete image */
document.addEventListener('click', function(e) {
  if (e.target && e.target.closest('.delete-icon')) {
    e.stopPropagation();
    const imageFilename = e.target.closest('.delete-icon').getAttribute('data-image');
    
    const deleteBaseUrl = "/delete_image/";
    const deleteUrl = deleteBaseUrl + encodeURIComponent(imageFilename);

    fetch(deleteUrl, { method: 'POST' })
      .then(function(response) {
        return response.json();
      })
      .then(function(data) {
        if (data.status === "success") {
          // Refresh the gallery instead of reloading the page
          currentPage = 1;
          loadImages(1);
        } else {
          console.error("Error deleting image:", data.message);
        }
      })
      .catch(function(error) {
        console.error("Error deleting image:", error);
      });
  }
});

/* Favorite toggle */
document.addEventListener('click', function(e) {
  if (e.target && e.target.closest('.favorite-icon')) {
    e.stopPropagation();
    const favIcon = e.target.closest('.favorite-icon');
    const imageFilename = favIcon.getAttribute('data-image');
    favIcon.classList.toggle('favorited');
    const isFavorited = favIcon.classList.contains('favorited');
    fetch("/api/update_image_metadata", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        filename: imageFilename,
        tags: [],  // do not modify tags in favorite toggle
        favorite: isFavorited
      })
    })
      .then(function(resp) {
        return resp.json();
      })
      .then(function(data) {
        if (data.status !== "success") {
          console.error("Error updating favorite:", data.message);
        }
      })
      .catch(function(err) {
        console.error("Error updating favorite:", err);
      });
  }
});

/* Info Modal Logic */
let currentInfoFilename = null;

document.addEventListener('click', function(e) {
  if (e.target && e.target.classList.contains('info-button')) {
    e.stopPropagation();
    const imageFilename = e.target.getAttribute('data-image');
    openInfoModal(imageFilename);
  }
});

/* Function to update current image display */
function updateCurrentImageDisplay() {
  fetch('/api/get_current_image')
    .then(response => response.json())
    .then(data => {
      if (data.status === "success" && data.image) {
        const currentImage = document.getElementById('currentImage');
        const currentImageTitle = document.getElementById('currentImageTitle');
        const currentImagePlaceholder = document.getElementById('currentImagePlaceholder');
        
        if (currentImage && data.image.filename) {
          if (data.image.is_screenshot) {
            currentImage.src = `/screenshots/${encodeURIComponent(data.image.filename)}?cropped=true`;
          } else {
            currentImage.src = `/images/${encodeURIComponent(data.image.filename)}`;
          }
          currentImage.style.display = 'block';
          if (currentImagePlaceholder) {
            currentImagePlaceholder.style.display = 'none';
          }
        }
        
        if (currentImageTitle && data.device) {
          currentImageTitle.textContent = `Current image on ${data.device.friendly_name}`;
        }
      }
    })
    .catch(error => {
      console.error("Error updating current image:", error);
    });
}

/* Function to open info modal */
function openInfoModal(filename) {
  currentInfoFilename = filename;
  
  // Reset the form
  document.getElementById('tagContainer').innerHTML = '';
  document.getElementById('infoStatus').textContent = '';
  
  // Show loading state
  document.getElementById('infoFilename').textContent = 'Loading...';
  document.getElementById('infoResolution').textContent = 'Loading...';
  document.getElementById('infoFilesize').textContent = 'Loading...';
  
  // Show the modal
  const infoModal = new bootstrap.Modal(document.getElementById('infoModal'));
  infoModal.show();
  
  // Load image data
  fetch(`/api/get_image_metadata?filename=${encodeURIComponent(filename)}`)
    .then(response => response.json())
    .then(data => {
      if (data.status === "success") {
        // Update basic info
        document.getElementById('infoFilename').textContent = filename;
        document.getElementById('infoResolution').textContent = data.resolution || 'N/A';
        document.getElementById('infoFilesize').textContent = data.filesize || 'N/A';
        document.getElementById('infoFavorite').checked = data.favorite || false;
        
        // Update preview image
        const previewImg = document.getElementById('infoImagePreview');
        previewImg.dataset.src = `/images/${encodeURIComponent(filename)}`;
        previewImg.src = `/images/${encodeURIComponent(filename)}`;
        
        // Update tags
        const tagContainer = document.getElementById('tagContainer');
        tagContainer.innerHTML = '';
        
        if (data.tags && data.tags.length > 0) {
          data.tags.forEach(tag => {
            const tagEl = document.createElement('span');
            tagEl.className = 'badge bg-primary me-1 mb-1 p-2';
            tagEl.textContent = tag;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn-close btn-close-white ms-1';
            removeBtn.setAttribute('aria-label', 'Remove');
            removeBtn.style.fontSize = '0.5rem';
            removeBtn.onclick = function() {
              removeTag(tag);
            };
            
            tagEl.appendChild(removeBtn);
            tagContainer.appendChild(tagEl);
          });
          
          document.getElementById('infoTags').value = data.tags.join(',');
        }
      } else {
        console.error("Error loading image info:", data.message);
      }
    })
    .catch(error => {
      console.error("Error loading image info:", error);
    });
}

/* Tag management functions */
function addTag() {
  const newTagInput = document.getElementById('newTagInput');
  const tag = newTagInput.value.trim();
  
  if (!tag) return;
  
  // Get current tags
  const infoTags = document.getElementById('infoTags');
  const currentTags = infoTags.value ? infoTags.value.split(',') : [];
  
  // Check if tag already exists
  if (currentTags.includes(tag)) {
    newTagInput.value = '';
    return;
  }
  
  // Add new tag
  currentTags.push(tag);
  infoTags.value = currentTags.join(',');
  
  // Add tag element
  const tagContainer = document.getElementById('tagContainer');
  const tagEl = document.createElement('span');
  tagEl.className = 'badge bg-primary me-1 mb-1 p-2';
  tagEl.textContent = tag;
  
  const removeBtn = document.createElement('button');
  removeBtn.className = 'btn-close btn-close-white ms-1';
  removeBtn.setAttribute('aria-label', 'Remove');
  removeBtn.style.fontSize = '0.5rem';
  removeBtn.onclick = function() {
    removeTag(tag);
  };
  
  tagEl.appendChild(removeBtn);
  tagContainer.appendChild(tagEl);
  
  // Clear input
  newTagInput.value = '';
}

function removeTag(tag) {
  // Get current tags
  const infoTags = document.getElementById('infoTags');
  let currentTags = infoTags.value ? infoTags.value.split(',') : [];
  
  // Remove tag
  currentTags = currentTags.filter(t => t !== tag);
  infoTags.value = currentTags.join(',');
  
  // Update UI
  const tagContainer = document.getElementById('tagContainer');
  const tagElements = tagContainer.querySelectorAll('.badge');
  
  tagElements.forEach(el => {
    if (el.textContent.includes(tag)) {
      el.remove();
    }
  });
}

function saveInfoEdits() {
  const infoStatus = document.getElementById('infoStatus');
  infoStatus.textContent = 'Saving...';
  
  const tags = document.getElementById('infoTags').value ?
    document.getElementById('infoTags').value.split(',') : [];
  const favorite = document.getElementById('infoFavorite').checked;
  
  fetch("/api/update_image_metadata", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      filename: currentInfoFilename,
      tags: tags,
      favorite: favorite
    })
  })
    .then(response => response.json())
    .then(data => {
      if (data.status === "success") {
        infoStatus.textContent = 'Saved successfully!';
        
        // Refresh gallery to show updated metadata
        setTimeout(() => {
          loadImages(currentPage);
        }, 1000);
      } else {
        infoStatus.textContent = 'Error saving: ' + data.message;
      }
    })
    .catch(error => {
      infoStatus.textContent = 'Error saving metadata';
      console.error("Error saving metadata:", error);
    });
}

function runOpenClip() {
  const infoStatus = document.getElementById('infoStatus');
  infoStatus.textContent = 'Running AI tagging...';
  
  fetch(`/api/run_openclip/${encodeURIComponent(currentInfoFilename)}`, {
    method: "POST"
  })
    .then(response => response.json())
    .then(data => {
      if (data.status === "success") {
        infoStatus.textContent = 'AI tagging complete!';
        
        // Reload the info modal to show new tags
        openInfoModal(currentInfoFilename);
      } else {
        infoStatus.textContent = 'Error running AI tagging: ' + data.message;
      }
    })
    .catch(error => {
      infoStatus.textContent = 'Error running AI tagging';
      console.error("Error running AI tagging:", error);
    });
}

function closeInfoModal() {
  const infoModalEl = document.getElementById('infoModal');
  const infoModal = bootstrap.Modal.getInstance(infoModalEl);
  if (infoModal) {
    infoModal.hide();
  }
}

// Variable to store the cropper instance
let cropper = null;

// Store original image dimensions for scaling
let originalImageWidth = 0;
let originalImageHeight = 0;

function openCropModal() {
  // Set up crop image
  const cropImage = document.getElementById('cropImage');
  cropImage.dataset.src = `/images/${encodeURIComponent(currentInfoFilename)}`;
  cropImage.src = `/images/${encodeURIComponent(currentInfoFilename)}`;
  
  // Reset original dimensions
  originalImageWidth = 0;
  originalImageHeight = 0;
  
  // Reset the save button state
  const saveBtn = document.querySelector('#cropModal .btn-primary');
  if (saveBtn) {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Save Crop';
  }
  
  // Get selected device information
  const selectedDevice = document.querySelector('input[name="device"]:checked');
  let deviceOrientation = 'landscape'; // Default to landscape
  let deviceResolution = '800x600'; // Default resolution
  
  if (selectedDevice) {
    // Get device resolution from data attribute
    deviceResolution = selectedDevice.getAttribute('data-resolution') || '800x600';
    
    // Get device orientation from data attribute
    deviceOrientation = selectedDevice.getAttribute('data-orientation') || 'landscape';
    
    console.log(`Selected device: ${selectedDevice.getAttribute('data-friendly')}, orientation: ${deviceOrientation}, resolution: ${deviceResolution}`);
  }
  
  // Add device info to the modal title
  const modalTitle = document.getElementById('cropModalLabel');
  modalTitle.textContent = `Crop Image for ${deviceOrientation} display (${deviceResolution})`;
  
  // Show the modal
  const cropModal = new bootstrap.Modal(document.getElementById('cropModal'));
  cropModal.show();
  // Initialize cropper after the modal is shown
  document.getElementById('cropModal').addEventListener('shown.bs.modal', initializeCropper);
}

// Global function to initialize cropper
function initializeCropper(deviceOrientation, deviceResolution) {
  console.log(`Initializing cropper with device: orientation=${deviceOrientation}, resolution=${deviceResolution}`);
  // Destroy existing cropper if it exists
  if (cropper) {
    cropper.destroy();
  }
  
  console.log("Initializing cropper for modal...");
  console.log(`Using device orientation: ${deviceOrientation}, resolution: ${deviceResolution}`);
  // First check if there are existing crop settings for this image
  console.log(`Checking for existing crop settings for ${currentInfoFilename}`);
  fetch(`/api/get_crop_info/${encodeURIComponent(currentInfoFilename)}`)
    fetch(`/api/get_crop_info/${encodeURIComponent(currentInfoFilename)}`)
      .then(response => response.json())
      .then(data => {
        console.log('Crop info response:', data);
        
        // Store original dimensions for scaling
        if (data.original_dimensions) {
          originalImageWidth = data.original_dimensions.width;
          originalImageHeight = data.original_dimensions.height;
          console.log(`Original image dimensions: ${originalImageWidth}x${originalImageHeight}`);
        }
        
        // Check if data exists and has the expected structure
        const hasCropData = data.status === "success" && data.crop_info !== null;
        console.log('Has existing crop data:', hasCropData);
        
        // Mark the modal with a data attribute to indicate we have crop data
        document.getElementById('cropModal').setAttribute('data-has-crop-data', hasCropData.toString());
        
        // Calculate the aspect ratio based on device resolution and orientation
        let aspectRatio = NaN; // Default to free aspect ratio
        
        if (deviceResolution) {
          const parts = deviceResolution.split('x');
          if (parts.length === 2) {
            const width = parseInt(parts[0], 10);
            const height = parseInt(parts[1], 10);
            
            if (!isNaN(width) && !isNaN(height) && width > 0 && height > 0) {
              // Set aspect ratio based on device orientation
              if (deviceOrientation === 'portrait') {
                // For portrait displays, the physical display is rotated 90°
                // So we need to swap the dimensions and use height/width (taller than wide)
                console.log(`Portrait display: swapping dimensions ${width}x${height} -> ${height}x${width}`);
                aspectRatio = height / width;
              } else {
                // For landscape displays, use width/height (wider than tall)
                aspectRatio = width / height;
              }
              // Save aspect ratio to global variable so it can be used later
              currentAspectRatio = aspectRatio;
              console.log(`Setting aspect ratio to ${aspectRatio} for ${deviceOrientation} display (${deviceResolution})`);
            }
          }
        }
        
        // Improved function to set the default crop box
        function setDefaultCropBox(cropperInstance) {
          // Get the most up-to-date data
          const containerData = cropperInstance.getContainerData();
          const imageData = cropperInstance.getImageData();
          const canvasData = cropperInstance.getCanvasData();
          
          console.log("Setting default crop box with:", {
            container: containerData,
            image: imageData,
            canvas: canvasData,
            aspectRatio: aspectRatio
          });
          
          // Calculate the maximum possible crop box size while maintaining aspect ratio
          let maxWidth, maxHeight;
          
          if (aspectRatio > 0) {
            // If image is wider than it is tall (landscape)
            if (imageData.width / imageData.height > aspectRatio) {
              maxHeight = imageData.height;
              maxWidth = maxHeight * aspectRatio;
            }
            // If image is taller than it is wide (portrait)
            else {
              maxWidth = imageData.width;
              maxHeight = maxWidth / aspectRatio;
            }
            
            // Important: Account for canvas position when placing the crop box
            // The canvas is the actual image display area within the container
            const cropData = {
              left: canvasData.left + (canvasData.width - maxWidth) / 2,
              top: canvasData.top + (canvasData.height - maxHeight) / 2,
              width: maxWidth,
              height: maxHeight
            };
            
            console.log(`Setting default crop box to ${maxWidth}x${maxHeight} at position ${cropData.left},${cropData.top}`);
            
            // Force crop mode to ensure visibility
            cropperInstance.setDragMode('crop');
            
            // Set the crop box with our calculated values
            cropperInstance.setCropBoxData(cropData);
          }
        }
        
        // Initialize Cropper.js with the calculated aspect ratio
        cropper = new Cropper(cropImage, {
          viewMode: 1,
          dragMode: 'crop',
          aspectRatio: aspectRatio, // Use the calculated aspect ratio based on device
          autoCropArea: 1, // Use maximum possible area (1 = 100%)
          restore: false,
          guides: true,
          center: true,
          highlight: false,
          cropBoxMovable: true,
          cropBoxResizable: true,
          toggleDragModeOnDblclick: false,
          responsive: true,     // Make it responsive to window resizing
          wheelZoomRatio: 0.1,  // Slower zoom for more precision
          ready: function() {
            // Log when cropper is ready
            console.log('Cropper instance initialized');
            
            // When the cropper is ready, check if we have existing crop data
            if (hasCropData) {
              try {
                console.log('Applying existing crop data:', data.crop_info);
                
                // Get key measurements from the cropper
                const imageData = this.cropper.getImageData(); // Image as displayed
                const canvasData = this.cropper.getCanvasData(); // Canvas containing the image
                const containerData = this.cropper.getContainerData(); // Outer container
                
                console.log("Image data:", imageData);
                console.log("Canvas data:", canvasData);
                console.log("Container data:", containerData);
                
                // IMPORTANT: Use the ACTUAL displayed size, not the natural size
                const displayedWidth = imageData.width; // Actual width of image as displayed
                const displayedHeight = imageData.height; // Actual height of image as displayed
                
                // Calculate scaling factors from original full-res to display size
                let scaleX = 1;
                let scaleY = 1;
                
                if (originalImageWidth > 0 && originalImageHeight > 0 &&
                    displayedWidth > 0 && displayedHeight > 0) {
                  // Scale from original full-res to currently displayed size
                  scaleX = displayedWidth / originalImageWidth;
                  scaleY = displayedHeight / originalImageHeight;
                  
                  console.log(`Scaling factors (original → displayed): ${scaleX}x, ${scaleY}y`);
                  console.log(`Original crop from database: x=${data.crop_info.x}, y=${data.crop_info.y}, w=${data.crop_info.width}, h=${data.crop_info.height}`);
                }
                
                // Scale the coordinates from original image size to displayed size
                const scaledX = Math.round(data.crop_info.x * scaleX);
                const scaledY = Math.round(data.crop_info.y * scaleY);
                const scaledWidth = Math.min(Math.round(data.crop_info.width * scaleX), displayedWidth);
                const scaledHeight = Math.min(Math.round(data.crop_info.height * scaleY), displayedHeight);
                
                console.log(`Scaled for display view: x=${scaledX}, y=${scaledY}, w=${scaledWidth}, h=${scaledHeight}`);
                
                // The canvas may be offset within the container
                // We need to account for these offsets when positioning the crop box
                const canvasLeft = canvasData.left;
                const canvasTop = canvasData.top;
                
                // Calculate the final position of the crop box relative to canvas
                const cropBoxData = {
                  left: canvasLeft + scaledX,  // Position relative to canvas left
                  top: canvasTop + scaledY,    // Position relative to canvas top
                  width: scaledWidth,
                  height: scaledHeight
                };
                
                console.log("Setting crop box data:", cropBoxData);
                
                // Before we apply the crop box, we need to make sure the image is ready
                // Wait for any automatic positioning to complete
                setTimeout(() => {
                  // DO NOT reset() or clear() the cropper - this will remove the crop box!
                  
                  // Make sure we're in crop mode
                  this.cropper.setDragMode('crop');
                  
                  // Force crop mode
                  this.cropper.setDragMode('crop');
                  
                  // Define directCropData at the start so it's available in all branches
                  let directCropData = {
                    left: scaledX + canvasLeft,
                    top: scaledY + canvasTop,
                    width: scaledWidth,
                    height: scaledHeight
                  };
                  
                  // Check if this is a full-width/full-height crop
                  const isFullWidth = data.crop_info.width >= originalImageWidth - 10; // Allow 10px margin for rounding
                  const isFullHeight = data.crop_info.height >= originalImageHeight - 10;
                  
                  // If this is a maximum crop (full-width or height), we'll take a special approach
                  if (isFullWidth || isFullHeight) {
                    console.log("Detected a maximum-size crop, using special handling");
                    
                    // For max crops, set to maximum possible size within the container
                    const containerData = this.cropper.getContainerData();
                    
                    // Create a crop box that fills the maximum area while maintaining aspect ratio
                    let maxWidth, maxHeight;
                    const aspectRatio = currentAspectRatio || 1.6666667;
                    
                    if (imageData.width / imageData.height > aspectRatio) {
                      maxHeight = imageData.height;
                      maxWidth = maxHeight * aspectRatio;
                    } else {
                      maxWidth = imageData.width;
                      maxHeight = maxWidth / aspectRatio;
                    }
                    
                    // Set data with forced maximum dimensions
                    this.cropper.setData({
                      x: 0,
                      y: 0,
                      width: imageData.width,
                      height: imageData.height,
                      rotate: 0,
                      scaleX: 1,
                      scaleY: 1
                    });
                    
                    // Then also try direct crop box setting
                    const maxCropData = {
                      left: canvasLeft,
                      top: canvasTop,
                      width: canvasData.width,
                      height: maxHeight
                    };
                    
                    // Update directCropData to use the max crop data
                    directCropData = maxCropData;
                    
                    console.log("Using maximum crop size:", maxCropData);
                    this.cropper.setCropBoxData(maxCropData);
                  } else {
                    // Normal case - use the scaled crop data
                    console.log("Setting crop box directly with:", directCropData);
                    
                    // Apply the crop box position directly
                    this.cropper.setCropBoxData(directCropData);
                    
                    // Second approach: try to set crop data via the built-in method
                    this.cropper.setData({
                      x: scaledX,
                      y: scaledY,
                      width: scaledWidth,
                      height: scaledHeight,
                      rotate: 0,
                      scaleX: 1,
                      scaleY: 1
                    });
                  }
                  
                  // Store the crop position in a dataset attribute for reference
                  document.getElementById('cropModal').dataset.cropPosition = JSON.stringify({
                    x: scaledX,
                    y: scaledY,
                    width: scaledWidth,
                    height: scaledHeight
                  });
                  
                  // Check if crop box is visible after setting data
                  setTimeout(() => {
                    const currentCropBox = this.cropper.getCropBoxData();
                    console.log("Current crop box after direct set:", currentCropBox);
                    
                    // If crop position doesn't match expected, try once more
                    if (Math.abs(currentCropBox.left - (scaledX + canvasLeft)) > 5 ||
                        Math.abs(currentCropBox.top - (scaledY + canvasTop)) > 5) {
                      console.log("Crop position doesn't match expected, applying again");
                      this.cropper.setCropBoxData(directCropData);
                    }
                    
                    // If we still don't have valid crop box data, try one more approach
                    if (!currentCropBox || !currentCropBox.width || !currentCropBox.height) {
                      console.log("Still no valid crop box, trying alternative approach");
                      
                      // Force the crop box to appear by directly setting crop data (not box data)
                      const cropData = this.cropper.getData();
                      console.log("Current crop data:", cropData);
                      
                      // Set crop data using the cropper's built-in method that handles constraints
                      // This is more reliable than setting crop box directly
                      const targetCropData = {
                        x: scaledX,
                        y: scaledY,
                        width: scaledWidth,
                        height: scaledHeight,
                        rotate: 0,
                        scaleX: 1,
                        scaleY: 1
                      };
                      
                      console.log("Setting crop data to:", targetCropData);
                      this.cropper.setData(targetCropData);
                    }
                  }, 200);
                }, 50);
                
                console.log('Successfully applied existing crop data');
              } catch (error) {
                console.error('Error applying existing crop data:', error);
                // Fall back to default behavior if there's an error - use global function
                globalSetDefaultCropBox(this.cropper);
              }
            } else {
              // No existing crop data, use default behavior - use global function
              console.log('No existing crop data found, using default settings');
              globalSetDefaultCropBox(this.cropper);
            }
          }
        });
      })
      .catch(error => {
        console.error('Error fetching crop info:', error);
        
        // Even if the fetch fails, try to get the original dimensions from the image
        try {
          const img = new Image();
          img.onload = function() {
            originalImageWidth = this.naturalWidth;
            originalImageHeight = this.naturalHeight;
            console.log(`Got original dimensions from error handler: ${originalImageWidth}x${originalImageHeight}`);
          };
          img.src = `/images/${encodeURIComponent(currentInfoFilename)}`;
        } catch (imgError) {
          console.error('Could not load image for dimensions:', imgError);
        }
        
        // Initialize Cropper.js with default settings if fetch fails
        // Calculate the aspect ratio based on device resolution and orientation
        // Use the parameters passed to the function
        let aspectRatio = NaN; // Default to free aspect ratio
        
        if (deviceResolution) {
          const parts = deviceResolution.split('x');
          if (parts.length === 2) {
            const width = parseInt(parts[0], 10);
            const height = parseInt(parts[1], 10);
            
            if (!isNaN(width) && !isNaN(height) && width > 0 && height > 0) {
              // Set aspect ratio based on device orientation parameter
              if (deviceOrientation === 'portrait') {
                // For portrait displays, the physical display is rotated 90°
                console.log(`Portrait display: swapping dimensions ${width}x${height} -> ${height}x${width}`);
                aspectRatio = height / width;
              } else {
                // For landscape displays, use width/height (wider than tall)
                aspectRatio = width / height;
              }
              console.log(`Setting aspect ratio to ${aspectRatio} for ${deviceOrientation} display (${deviceResolution})`);
            }
          }
        }
        
        // Function to set the default crop box (used when no existing crop data exists)
        function setDefaultCropBox(cropperInstance) {
          const containerData = cropperInstance.getContainerData();
          const imageData = cropperInstance.getImageData();
          
          // Calculate the maximum possible crop box size centered in the image
          // This ensures we create a center crop for images that haven't been cropped before
          let maxWidth, maxHeight;
          
          if (aspectRatio > 0) {
            if (imageData.width / imageData.height > aspectRatio) {
              maxHeight = imageData.height;
              maxWidth = maxHeight * aspectRatio;
            } else {
              maxWidth = imageData.width;
              maxHeight = maxWidth / aspectRatio;
            }
            
            // Set the crop box to the maximum size
            cropperInstance.setCropBoxData({
              left: (containerData.width - maxWidth) / 2,
              top: (containerData.height - maxHeight) / 2,
              width: maxWidth,
              height: maxHeight
            });
            
            console.log(`Set initial crop box to ${maxWidth}x${maxHeight}`);
          }
        }
        
        // Initialize Cropper.js with the calculated aspect ratio
        cropper = new Cropper(cropImage, {
          viewMode: 1,
          dragMode: 'move',
          aspectRatio: aspectRatio,
          autoCropArea: 1,
          restore: false,
          guides: true,
          center: true,
          highlight: false,
          cropBoxMovable: true,
          cropBoxResizable: true,
          toggleDragModeOnDblclick: false,
          ready: function() {
            // Set default crop box
            setDefaultCropBox(this.cropper);
          }
        });
      });
}

// Add a note about device orientation to the modal function
function updateOrientationNote(deviceOrientation, deviceResolution) {
  const modalBody = document.querySelector('#cropModal .modal-body');
  let orientationNote = document.getElementById('orientationNote');
  
  if (!orientationNote) {
    orientationNote = document.createElement('div');
    orientationNote.id = 'orientationNote';
    orientationNote.className = 'alert alert-info mt-3';
    modalBody.appendChild(orientationNote);
  }
  
  // Prepare the orientation-specific message without using a multi-line ternary operator (which causes syntax errors)
  let orientationMsg = '';
  if (deviceOrientation === 'portrait') {
    orientationMsg = 'Since your display is in portrait mode, the image will be rotated 90° clockwise after cropping to fit correctly.';
  } else {
    orientationMsg = 'Since your display is in landscape mode, the image will be sent exactly as cropped, without rotation.';
  }
  
  orientationNote.innerHTML = `
    <strong>Note:</strong> You are cropping for a <strong>${deviceOrientation}</strong> display (${deviceResolution}).
    <br>The crop area is locked to the correct aspect ratio for your display and starts at the maximum possible size.
    <br>You can move and resize the crop area to select which part of the image to send.
    <br>${orientationMsg}
  `;
}

// Complete the openCropModal function
function openCropModal() {
  // Set up crop image
  const cropImage = document.getElementById('cropImage');
  cropImage.dataset.src = `/images/${encodeURIComponent(currentInfoFilename)}`;
  cropImage.src = `/images/${encodeURIComponent(currentInfoFilename)}`;
  
  // Reset original dimensions
  originalImageWidth = 0;
  originalImageHeight = 0;
  
  // Get the crop modal element
  const cropModalEl = document.getElementById('cropModal');
  
  // Initialize the crop data flag to false - will be updated when data is fetched
  cropModalEl.setAttribute('data-has-crop-data', 'false');
  
  // Clear any previous saved crop position
  delete cropModalEl.dataset.cropPosition;
  
  // Reset the save button state
  const saveBtn = document.querySelector('#cropModal .btn-primary');
  if (saveBtn) {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Save Crop';
  }
  
  // Get selected device information
  const selectedDevice = document.querySelector('input[name="device"]:checked');
  let deviceOrientation = 'landscape'; // Default to landscape
  let deviceResolution = '800x600'; // Default resolution
  
  if (selectedDevice) {
    // Get device resolution from data attribute
    deviceResolution = selectedDevice.getAttribute('data-resolution') || '800x600';
    
    // Get device orientation from data attribute
    deviceOrientation = selectedDevice.getAttribute('data-orientation') || 'landscape';
    
    console.log(`Selected device: ${selectedDevice.getAttribute('data-friendly')}, orientation: ${deviceOrientation}, resolution: ${deviceResolution}`);
  }
  
  // Add device info to the modal title
  const modalTitle = document.getElementById('cropModalLabel');
  modalTitle.textContent = `Crop Image for ${deviceOrientation} display (${deviceResolution})`;
  
  // First prefetch crop info to have it ready when modal opens
  fetch(`/api/get_crop_info/${encodeURIComponent(currentInfoFilename)}`)
    .then(response => response.json())
    .then(data => {
      if (data.status === "success" && data.crop_info) {
        // Mark modal as having crop data
        cropModalEl.setAttribute('data-has-crop-data', 'true');
        
        // Store original dimensions for scaling
        if (data.original_dimensions) {
          originalImageWidth = data.original_dimensions.width;
          originalImageHeight = data.original_dimensions.height;
        }
        
        // Store the crop position in a dataset attribute for reference
        cropModalEl.dataset.cropPosition = JSON.stringify({
          x: data.crop_info.x || 0,
          y: data.crop_info.y || 0,
          width: data.crop_info.width || 0,
          height: data.crop_info.height || 0
        });
      }
      
      // Now show the modal after getting the data
      const cropModal = new bootstrap.Modal(cropModalEl);
      cropModal.show();
      
      // Initialize cropper after the modal is shown - pass needed parameters
      // Use one-time event listener to avoid stacking multiple listeners
      const initCropperOnce = function() {
        initializeCropper(deviceOrientation, deviceResolution);
        cropModalEl.removeEventListener('shown.bs.modal', initCropperOnce);
      };
      cropModalEl.addEventListener('shown.bs.modal', initCropperOnce);
      
      // Update the orientation note
      updateOrientationNote(deviceOrientation, deviceResolution);
    })
    .catch(error => {
      console.error("Error pre-fetching crop info:", error);
      
      // Show modal anyway even if prefetch fails
      const cropModal = new bootstrap.Modal(cropModalEl);
      cropModal.show();
      
      // Initialize cropper after the modal is shown
      const initCropperOnce = function() {
        initializeCropper(deviceOrientation, deviceResolution);
        cropModalEl.removeEventListener('shown.bs.modal', initCropperOnce);
      };
      cropModalEl.addEventListener('shown.bs.modal', initCropperOnce);
      
      // Update the orientation note
      updateOrientationNote(deviceOrientation, deviceResolution);
    });
}
function closeCropModal() {
  const cropModalEl = document.getElementById('cropModal');
  const cropModal = bootstrap.Modal.getInstance(cropModalEl);
  if (cropModal) {
    cropModal.hide();
  }
  
  // We need to remove the anonymous function handler, not the initializeCropper function itself
  // For simplicity, we'll rely on the fact that the modal creates a new handler each time
  
  // Reset the crop data flag
  cropModalEl.setAttribute('data-has-crop-data', 'false');
  
  // Destroy cropper instance when modal is closed
  if (cropper) {
    cropper.destroy();
    cropper = null;
  }
  
  // Reset the save button state
  const saveBtn = document.querySelector('#cropModal .btn-primary');
  if (saveBtn) {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Save Crop';
  }
}
function saveCropData() {
  if (!cropper) {
    console.error("Cropper not initialized");
    alert("Error: Cropper not initialized. Please try again.");
    return;
  }
  
  try {
    // Make sure the cropper is valid and ready
    if (!cropper.ready) {
      console.error("Cropper not ready");
      alert("Error: Cropper not ready. Please try again.");
      return;
    }
    
    // Get the image dimensions from the cropper
    const cropperImageData = cropper.getImageData();
    const displayWidth = cropperImageData.naturalWidth; // What's shown in the browser
    const displayHeight = cropperImageData.naturalHeight;
    
    // It's critical to get the image dimensions correctly here
    // We need both the displayed size and the original full-res size
    const displayedImage = cropper.getImageData();
    const displayedWidth = displayedImage.width; // Actual width of image as shown, not naturalWidth
    const displayedHeight = displayedImage.height;
    
    // Get crop data from cropper (relative to the currently displayed image)
    // Use try/catch to prevent errors when getting data
    let cropData;
    try {
      cropData = cropper.getData(true); // rounded to integers
    } catch (error) {
      console.error("Error getting crop data:", error);
      alert("Error getting crop data. Please try again.");
      return;
    }
    
    // Calculate scaling factors between displayed image and original full-res image
    let scaleX = 1;
    let scaleY = 1;
    
    if (originalImageWidth > 0 && originalImageHeight > 0 &&
        displayedWidth > 0 && displayedHeight > 0) {
      // Scale from display size back to original full-res size
      scaleX = originalImageWidth / displayedWidth;
      scaleY = originalImageHeight / displayedHeight;
      
      console.log(`Save scaling factors (displayed → original): ${scaleX}x, ${scaleY}y`);
      console.log(`Displayed image: ${displayedWidth}x${displayedHeight}`);
      console.log(`Original image: ${originalImageWidth}x${originalImageHeight}`);
      console.log(`Crop on display: x=${cropData.x}, y=${cropData.y}, w=${cropData.width}, h=${cropData.height}`);
      
      // Scale the crop coordinates to match the original image
      cropData.x = Math.round(cropData.x * scaleX);
      cropData.y = Math.round(cropData.y * scaleY);
      cropData.width = Math.round(cropData.width * scaleX);
      cropData.height = Math.round(cropData.height * scaleY);
      
      console.log(`Scaled crop for original: x=${cropData.x}, y=${cropData.y}, w=${cropData.width}, h=${cropData.height}`);
    } else {
      console.warn("Could not scale crop coordinates - missing dimension information");
      console.log(`Available dimensions: displayed=${displayedWidth}x${displayedHeight}, original=${originalImageWidth}x${originalImageHeight}`);
      console.log(`Display dimensions: ${displayWidth}x${displayHeight}`);
      console.log(`Original dimensions: ${originalImageWidth}x${originalImageHeight}`);
    }
    
    // Get selected device for resolution info
    const selectedDevice = document.querySelector('input[name="device"]:checked');
    const deviceData = selectedDevice ? { device: selectedDevice.value } : {};
    
    // Combine crop data with device info
    const data = {
      ...cropData,
      ...deviceData
    };
    
    // Show saving indicator
    const saveBtn = document.querySelector('#cropModal .btn-primary');
    const originalText = saveBtn.textContent;
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
    
    // Send crop data to server
    fetch(`/save_crop_info/${encodeURIComponent(currentInfoFilename)}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
      if (result.status === "success") {
        // Show success message
        const infoStatus = document.getElementById('infoStatus');
        infoStatus.textContent = 'Crop saved successfully!';
        
        // Reset button state before closing modal
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
        
        // Close the crop modal
        closeCropModal();
      } else {
        console.error("Error saving crop data:", result.message);
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
        alert("Error saving crop data: " + (result.message || "Unknown error"));
      }
    })
    .catch(error => {
      console.error("Error saving crop data:", error);
      saveBtn.disabled = false;
      saveBtn.textContent = originalText;
      alert("Error saving crop data: " + error.message);
    });
  } catch (error) {
    console.error("Error in saveCropData:", error);
    alert("An error occurred while processing crop data. Please try again.");
    
    // Reset button state
    const saveBtn = document.querySelector('#cropModal .btn-primary');
    if (saveBtn) {
      saveBtn.disabled = false;
      saveBtn.textContent = 'Save Crop';
    }
  }
}
// Simple function to set default crop box
function globalSetDefaultCropBox(cropperInstance) {
  if (!cropperInstance) return;

  try {
    // Set crop mode first
    cropperInstance.setDragMode('crop');
    
    // Check if we have saved crop position in the dataset
    const cropModal = document.getElementById('cropModal');
    const savedCropPosition = cropModal.dataset.cropPosition;
    
    if (savedCropPosition && cropModal.getAttribute('data-has-crop-data') === 'true') {
      try {
        // Use saved crop position if available
        console.log("Using saved crop position from dataset");
        const cropPosition = JSON.parse(savedCropPosition);
        
        // Get image data to determine if this is a full-width crop
        const imageData = cropperInstance.getImageData();
        const canvasData = cropperInstance.getCanvasData();
        const isFullWidth = cropPosition.width >= imageData.naturalWidth * 0.95; // Consider it full width if >95% of image width
        
        if (isFullWidth) {
          console.log("Detected a full-width crop, using maximum possible width");
          
          // Use the aspect ratio to calculate the maximum box
          const aspectRatio = currentAspectRatio || 1.6666667;
          
          // For a full-width crop, we want to make sure it takes the full width
          const maxWidth = canvasData.width;
          const maxHeight = maxWidth / aspectRatio;
          
          // Try multiple approaches to ensure the cropper sets the full width
          
          // Approach 1: Use setCropBoxData directly
          cropperInstance.setCropBoxData({
            left: canvasData.left,
            top: canvasData.top + (canvasData.height - maxHeight) / 2,
            width: maxWidth,
            height: maxHeight
          });
          
          // Approach 2: Also try setData
          cropperInstance.setData({
            x: 0,
            y: (imageData.height - imageData.width / aspectRatio) / 2,
            width: imageData.width,
            height: imageData.width / aspectRatio,
            rotate: 0,
            scaleX: 1,
            scaleY: 1
          });
          
          // Approach 3: Force a center crop with the proper aspect ratio
          setTimeout(() => {
            // One more attempt to ensure it takes the full width
            cropperInstance.setCropBoxData({
              left: canvasData.left,
              top: canvasData.top + (canvasData.height - maxHeight) / 2,
              width: maxWidth,
              height: maxHeight
            });
          }, 100);
        } else {
          // Normal crop - just use the saved position
          // First try with setData which is more reliable
          cropperInstance.setData({
            x: cropPosition.x,
            y: cropPosition.y,
            width: cropPosition.width,
            height: cropPosition.height,
            rotate: 0,
            scaleX: 1,
            scaleY: 1
          });
          
          // Also try setting the crop box directly
          cropperInstance.setCropBoxData({
            left: cropPosition.x + canvasData.left,
            top: cropPosition.y + canvasData.top,
            width: cropPosition.width,
            height: cropPosition.height
          });
        }
        
        console.log("Applied saved crop position:", cropPosition);
        return;
      } catch (parseErr) {
        console.error("Error applying saved crop position:", parseErr);
      }
    }
    
    // First check if there's already a valid crop box
    const currentBox = cropperInstance.getCropBoxData();
    if (currentBox && currentBox.width > 0 && currentBox.height > 0) {
      console.log("Crop box already exists:", currentBox);
      return; // Keep existing box
    }
    
    // Get current aspect ratio
    let aspectRatio = currentAspectRatio || 1.6666667;
    
    // If we got here, we need to create a crop box
    // Use a simple approach - create a centered crop box at maximum size
    const imageData = cropperInstance.getImageData();
    
    // Calculate maximum crop size that fits the aspect ratio
    let cropWidth, cropHeight;
    
    if (imageData.width / imageData.height > aspectRatio) {
      // Image is wider than the target ratio - constrain by height
      cropHeight = imageData.height;
      cropWidth = cropHeight * aspectRatio;
    } else {
      // Image is taller than target ratio - constrain by width
      cropWidth = imageData.width;
      cropHeight = cropWidth / aspectRatio;
    }
    
    // Let cropper handle the positioning logic
    console.log(`Setting crop box to ${cropWidth}x${cropHeight}`);
    
    // Use setData instead of setCropBoxData - more reliable
    cropperInstance.setData({
      x: (imageData.width - cropWidth) / 2,
      y: (imageData.height - cropHeight) / 2,
      width: cropWidth,
      height: cropHeight,
      rotate: 0
    });
    
    // Verify it worked
    console.log("Current crop box:", cropperInstance.getCropBoxData());
    
  } catch (err) {
    console.error("Error in globalSetDefaultCropBox:", err);
  }
}

// Global variable to store the current aspect ratio
let currentAspectRatio = null;

// Simple event listener for when the modal is shown
document.getElementById('cropModal').addEventListener('shown.bs.modal', function() {
  // Give time for cropper to initialize
  setTimeout(function() {
    if (!cropper) return;
    
    // Always ensure crop mode is active
    cropper.setDragMode('crop');
    
    // Get current box
    const cropBox = cropper.getCropBoxData();
    
    // Only create a default box if we have no existing crop data
    // Check if crop box is missing or has invalid dimensions
    if ((!cropBox || !cropBox.width || !cropBox.height ||
        cropBox.width <= 0 || cropBox.height <= 0) &&
        // Add this condition to prevent overriding saved crop data
        document.getElementById('cropModal').getAttribute('data-has-crop-data') !== 'true') {
      
      console.log("Creating default crop box");
      
      // Create using simpler approach directly with the cropper API
      const imgData = cropper.getImageData();
      const canvasData = cropper.getCanvasData();
      const aspect = currentAspectRatio || 1.6666667;
      
      // Always default to maximum width for the best user experience
      // This creates a crop box that takes the full width of the canvas
      const maxWidth = canvasData.width;
      const maxHeight = maxWidth / aspect;
      
      // First try setting the crop box directly
      cropper.setCropBoxData({
        left: canvasData.left,
        top: canvasData.top + (canvasData.height - maxHeight) / 2,
        width: maxWidth,
        height: maxHeight
      });
      
      // Also try using setData for reliability
      cropper.setData({
        x: 0,
        y: (imgData.height - imgData.width / aspect) / 2,
        width: imgData.width,
        height: imgData.width / aspect
      });
      
      console.log("Created default full-width crop box");
    }
  }, 300);
});
</script>
{% endblock %}
