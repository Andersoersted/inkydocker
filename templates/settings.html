{% extends "base.html" %}
{% block title %}Settings - InkyDocker{% endblock %}

{% block content %}
<div class="container py-4">
  <!-- Page Header -->
  <header class="pb-3 mb-4 border-bottom">
    <h1 class="display-5 fw-bold">Settings</h1>
    <p class="lead">Manage your eInk displays and AI settings.</p>
  </header>

  <!-- Tagging Settings Button -->
  <div class="card mb-4 shadow-sm">
    <div class="card-body text-center">
      <h5 class="card-title">Image Tagging Settings</h5>
      <p class="card-text">Configure tagging settings and test image tagging</p>
      <button id="openClipSettingsBtn" class="btn btn-primary" onclick="document.getElementById('clipSettingsModal').style.display = 'block';">
        <i class="bi bi-gear-fill"></i> Open Tagging Settings
      </button>
    </div>
  </div>

  <!-- Tagging Settings Modal -->
  <div id="clipSettingsModal" class="custom-modal">
    <div class="custom-modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Image Tagging Settings</h2>
        <button type="button" class="btn-close" id="closeClipSettingsModal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="clipSettingsForm">
          <!-- Main tabs for organization -->
          <ul class="nav nav-tabs mb-4" id="clipSettingsTabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="tagging-settings-tab" data-bs-toggle="tab" data-bs-target="#tagging-settings" type="button" role="tab" aria-controls="tagging-settings" aria-selected="true">Tagging Settings</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="test-model-tab" data-bs-toggle="tab" data-bs-target="#test-model" type="button" role="tab" aria-controls="test-model" aria-selected="false">Test Tagging</button>
            </li>
          </ul>
          
          <div class="tab-content" id="clipSettingsTabContent">
            <!-- Hidden inputs for RAM model settings -->
            <input type="hidden" id="ram_model" value="ram_large">
            <input type="hidden" id="ram_min_confidence"
                   value="{{ config.ram_min_confidence if config and config.ram_min_confidence else '0.3' }}">
            <input type="hidden" id="confidence_value"
                   value="{{ config.ram_min_confidence if config and config.ram_min_confidence else '0.3' }}">
            <input type="hidden" id="enable_ram" value="true">
            
            <!-- Model Download Progress -->
            <div id="modelDownloadContainer" class="mb-4" style="display: none;">
              <h6 class="mb-2">Downloading: <span id="modelDownloadName" class="fw-bold"></span></h6>
              <div class="progress" style="height: 25px;">
                <div id="modelDownloadProgress" class="progress-bar progress-bar-striped progress-bar-animated"
                     role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"
                     style="width: 0%;">0%</div>
              </div>
              <p id="modelDownloadStatus" class="text-muted mt-2 small"></p>
            </div>
            
            <!-- Tagging Settings Tab -->
            <div class="tab-pane fade" id="tagging-settings" role="tabpanel" aria-labelledby="tagging-settings-tab">
              <div class="row">
                <div class="col-md-6">
                  <div class="card mb-4">
                    <div class="card-body">
                      <h5 class="card-title">Maximum Tags per Image</h5>
                      <div class="mb-3">
                        <label for="min_tags" class="form-label">Number of tags (1-20):</label>
                        <input type="number" id="min_tags" name="min_tags" min="1" max="20"
                               value="{{ config.min_tags if config and config.min_tags else 5 }}"
                               class="form-control form-control-lg">
                        <div class="form-text">Set the maximum number of tags to generate for each image.</div>
                      </div>
                      <div class="d-grid">
                        <button type="button" class="btn btn-success" onclick="saveMinTags()">
                          <i class="bi bi-check-circle"></i> Save Setting
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="col-md-6">
                  <div class="card mb-4">
                    <div class="card-body">
                      <h5 class="card-title">Tag Confidence Threshold</h5>
                      <div class="mb-3">
                        <label for="ram_min_confidence" class="form-label">Minimum Confidence: <span id="confidence_value_global">{{ config.ram_min_confidence if config and config.ram_min_confidence else '0.3' }}</span></label>
                        <input type="range" class="form-range" id="ram_min_confidence_global" min="0.1" max="0.9" step="0.05"
                               value="{{ config.ram_min_confidence if config and config.ram_min_confidence else '0.3' }}"
                               oninput="document.getElementById('confidence_value_global').textContent = this.value; document.getElementById('ram_min_confidence').value = this.value; document.getElementById('confidence_value').textContent = this.value;">
                        <div class="form-text">Higher values mean fewer but more accurate tags.</div>
                      </div>
                      <div class="d-grid">
                        <button type="button" class="btn btn-success" onclick="saveRAMSettings()">
                          <i class="bi bi-check-circle"></i> Save Setting
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Rerun Tagging Button -->
              <div class="card">
                <div class="card-body text-center">
                  <h5 class="card-title">Rerun Tagging on All Images</h5>
                  <p class="card-text text-danger">
                    <i class="bi bi-exclamation-triangle"></i>
                    Warning: This will remove all existing tags and replace them with new ones.
                  </p>
                  <button type="button" class="btn btn-danger btn-lg" onclick="rerunAllTagging()">
                    <i class="bi bi-arrow-repeat"></i> Rerun Tagging on All Images
                  </button>
                </div>
              </div>
            </div>
            
            <!-- Test Model Tab -->
            <div class="tab-pane fade" id="test-model" role="tabpanel" aria-labelledby="test-model-tab">
              <div class="card">
                <div class="card-body">
                  <h5 class="card-title">Test Image Tagging</h5>
                  <p class="card-text">Upload a test image to verify the tagging system is working correctly and see the generated tags.</p>
                  
                  <div class="mb-3">
                    <label for="testImageFile" class="form-label">Select an image to test:</label>
                    <input class="form-control form-control-lg" type="file" id="testImageFile" accept="image/*">
                  </div>
                  
                  <div class="d-grid">
                    <button type="button" class="btn btn-primary btn-lg" onclick="testTagging()">
                      <i class="bi bi-tag"></i> Test Image Tagging
                    </button>
                  </div>
                  
                  <div id="testTaggingResult" class="mt-4" style="display: none;">
                    <h6 class="fw-bold">Test Results:</h6>
                    <div id="testTaggingContent" class="p-3 bg-light rounded"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </form>
      </div>
    </div>
  </div>
        
  </div>

  <!-- Add New Display Button -->
  <div class="card mb-4 shadow-sm">
    <div class="card-body text-center">
      <button id="addNewDisplayBtn" class="primary-btn" style="width: 100%; padding: 12px;">Add New Display</button>
    </div>
  </div>

  <!-- Add New Display Modal -->
  <div id="addDisplayModal" class="custom-modal">
    <div class="custom-modal-content">
      <span class="close" id="closeAddDisplayModal">&times;</span>
      <h2>Add New Display</h2>
      <form id="addDisplayForm" method="POST" action="{{ url_for('settings.settings') }}">
        <input type="text" name="address" id="newAddress" placeholder="Device Address (e.g., 192.168.1.100)" required>
        <select name="orientation" id="newOrientation" required>
          <option value="portrait">Portrait</option>
          <option value="landscape">Landscape</option>
        </select>
        <input type="text" name="friendly_name" id="newFriendlyName" placeholder="Friendly Name" required>
        <!-- Hidden fields populated by Fetch Display Info -->
        <input type="hidden" name="display_name" id="newDisplayName">
        <input type="hidden" name="resolution" id="newResolution">
        <input type="hidden" name="color" id="newColor">
        <div style="margin-top: 10px;">
          <button type="button" class="primary-btn" onclick="fetchDisplayInfo('new')">Fetch Display Info</button>
        </div>
        <div style="margin-top: 10px;">
          <button type="submit" class="primary-btn">Save</button>
          <button type="button" class="primary-btn" onclick="closeAddDisplayModal()">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Edit Display Modal -->
  <div id="editDisplayModal" class="custom-modal">
    <div class="custom-modal-content">
      <span class="close" id="closeEditDisplayModal">&times;</span>
      <h2>Edit Display</h2>
      <form id="editDisplayForm" method="POST" action="{{ url_for('settings.edit_device') }}">
        <input type="hidden" name="device_index" id="editDeviceIndex">
        <label for="editFriendlyName">Friendly Name:</label>
        <input type="text" name="friendly_name" id="editFriendlyName" placeholder="Friendly Name" required>
        <label for="editOrientation">Orientation:</label>
        <select name="orientation" id="editOrientation" required>
          <option value="portrait">Portrait</option>
          <option value="landscape">Landscape</option>
        </select>
        <label for="editAddress">Device Address:</label>
        <input type="text" name="address" id="editAddress" placeholder="Device Address" required>
        <div style="margin-top: 10px;">
          <button type="submit" class="primary-btn">Save Changes</button>
          <button type="button" class="primary-btn" onclick="closeEditDisplayModal()">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Advanced Actions Modal -->
  <div id="advancedActionsModal" class="custom-modal">
    <div class="custom-modal-content">
      <span class="close" id="closeAdvancedActionsModal">&times;</span>
      <h2>Advanced Actions</h2>
      <p id="advancedDeviceTitle" style="font-weight:bold;"></p>
      <div style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
        <button type="button" class="primary-btn" onclick="triggerSystemUpdate()">System Update & Reboot</button>
        <button type="button" class="primary-btn" onclick="triggerBackup()">Create Backup</button>
        <button type="button" class="primary-btn" onclick="triggerAppUpdate()">Update Application</button>
      </div>
      <div style="margin-top: 15px; text-align: center;">
        <button type="button" class="primary-btn" onclick="closeAdvancedActionsModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Existing Devices Card -->
  <div class="card">
    <h2>Existing Devices</h2>
    <table class="device-table">
      <thead>
        <tr>
          <th>#</th>
          <th>Color</th>
          <th>Friendly Name</th>
          <th>Orientation</th>
          <th>Address</th>
          <th>Display Name</th>
          <th>Resolution</th>
          <th>Status</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        {% for device in devices %}
        <tr data-index="{{ loop.index0 }}" data-address="{{ device.address }}">
          <td>{{ loop.index }}</td>
          <td>
            <div class="color-indicator" {% if device.color %}style="background-color:{{ device.color }};"{% endif %}></div>
          </td>
          <td>{{ device.friendly_name }}</td>
          <td>{{ device.orientation }}</td>
          <td>{{ device.address }}</td>
          <td>{{ device.display_name }}</td>
          <td>{{ device.resolution }}</td>
          <td>
            {% if device.online %}
              <span style="color:green;">&#9679;</span>
            {% else %}
              <span style="color:red;">&#9679;</span>
            {% endif %}
          </td>
          <td>
            <form method="POST" action="{{ url_for('settings.delete_device', device_index=loop.index0) }}" style="display:inline;">
              <input type="submit" value="Delete">
            </form>
            <button type="button" class="edit-button" onclick="openEditModal('{{ loop.index0 }}', '{{ device.friendly_name }}', '{{ device.orientation }}', '{{ device.address }}')">
              Edit
            </button>
            <button type="button" class="advanced-button" onclick="openAdvancedModal('{{ loop.index0 }}', '{{ device.friendly_name }}')">
              Advanced
            </button>
          </td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>
{% endblock %}

{% block head %}
<!-- Bootstrap Icons -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
<style>
  .custom-modal {
    display: none;
    position: fixed;
    z-index: 3000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.5);
  }
  .custom-modal-content {
    background-color: #fff;
    margin: 3% auto;
    padding: 0;
    border-radius: 8px;
    max-width: 800px;
    position: relative;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }
  
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #dee2e6;
  }
  
  .modal-body {
    padding: 1.5rem;
  }
  
  /* Special styling for the CLIP settings modal */
  #clipSettingsModal .custom-modal-content {
    max-width: 1000px;
    max-height: 90vh;
    overflow-y: auto;
  }
  .close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }
  .close:hover,
  .close:focus {
    color: #000;
  }
  .overlay-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 5000;
  }
  .overlay-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
    max-width: 400px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  .overlay-buttons {
    margin-top: 15px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  .cancel-btn {
    background: #6c757d;
    border: none;
    color: #fff;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
  }
  .cancel-btn:hover {
    background: #5a6268;
  }
  .progress-container {
    margin: 10px 0;
    background-color: #f1f1f1;
    border-radius: 5px;
    overflow: hidden;
  }
  .progress-bar {
    height: 20px;
    background-color: #4CAF50;
    text-align: center;
    line-height: 20px;
    color: white;
    transition: width 0.3s ease;
  }
  .color-indicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: #CCCCCC; /* Default color */
  }
</style>
{% endblock %}

{% block scripts %}
<script>
  // Global modal closing functions
  window.closeAddDisplayModal = function() {
    document.getElementById('addDisplayModal').style.display = 'none';
  };
  window.closeEditDisplayModal = function() {
    document.getElementById('editDisplayModal').style.display = 'none';
  };
  window.closeAdvancedActionsModal = function() {
    document.getElementById('advancedActionsModal').style.display = 'none';
  };
  window.closeClipSettingsModal = function() {
    document.getElementById('clipSettingsModal').style.display = 'none';
  };
  
  // Overlay message functions
  function showOverlayMessage(message, duration) {
    var overlay = document.createElement('div');
    overlay.className = 'overlay-popup';
    overlay.innerHTML = `
      <div class="overlay-content">
        <p>${message}</p>
        <button class="primary-btn" onclick="this.parentNode.parentNode.remove()">OK</button>
      </div>
    `;
    document.body.appendChild(overlay);
    
    if (duration) {
      setTimeout(function() {
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
      }, duration);
    }
  }
  
  function showConfirmOverlay(message, confirmCallback) {
    var overlay = document.createElement('div');
    overlay.className = 'overlay-popup';
    overlay.innerHTML = `
      <div class="overlay-content">
        <p>${message}</p>
        <div class="overlay-buttons">
          <button class="primary-btn" id="confirmYes">Yes</button>
          <button class="cancel-btn" id="confirmNo">No</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    document.getElementById('confirmYes').addEventListener('click', function() {
      overlay.parentNode.removeChild(overlay);
      if (typeof confirmCallback === 'function') {
        confirmCallback();
      }
    });
    
    document.getElementById('confirmNo').addEventListener('click', function() {
      overlay.parentNode.removeChild(overlay);
    });
  }

  // Device status checking
  
  function checkDeviceStatus() {
    fetch("/devices/status")
      .then(response => response.json())
      .then(data => {
        if(data.status === "success") {
          data.devices.forEach(function(device) {
            var row = document.querySelector('tr[data-index="' + device.index + '"]');
            if (row) {
              var statusCell = row.querySelector('td:nth-child(8)');
              if(device.online) {
                statusCell.innerHTML = '<span style="color:green;">&#9679;</span>';
              } else {
                statusCell.innerHTML = '<span style="color:red;">&#9679;</span>';
              }
            }
          });
        }
      })
      .catch(error => {
        console.error("Error checking device status:", error);
      });
  }
  setInterval(checkDeviceStatus, 5000);
  checkDeviceStatus();

  // Modal functions for editing and advanced actions
  function openEditModal(index, friendlyName, orientation, address) {
    document.getElementById('editDisplayModal').style.display = 'block';
    document.getElementById('editDeviceIndex').value = index;
    document.getElementById('editFriendlyName').value = friendlyName;
    document.getElementById('editOrientation').value = orientation;
    document.getElementById('editAddress').value = address;
  }

  function openAdvancedModal(index, friendlyName) {
    document.getElementById('advancedActionsModal').style.display = 'block';
    document.getElementById('advancedDeviceTitle').textContent = "Advanced Actions for " + friendlyName;
    document.getElementById('advancedActionsModal').setAttribute('data-device-index', index);
  }
  
  // Device API functions: triggerSystemUpdate, triggerBackup, triggerAppUpdate remain unchanged
  function triggerSystemUpdate() {
    var deviceIndex = document.getElementById('advancedActionsModal').getAttribute('data-device-index');
    var deviceRow = document.querySelector('tr[data-index="' + deviceIndex + '"]');
    var deviceAddress = deviceRow.getAttribute('data-address');
    if (!deviceAddress) {
      showOverlayMessage("Error: Device address not found");
      return;
    }
    showConfirmOverlay(
      "This will trigger a system update and reboot the device. Continue?",
      function() {
        // Show a brief message and close the modal immediately
        showOverlayMessage("System update command sent. The device will update and reboot automatically.", 2000);
        closeAdvancedActionsModal();
        
        // Send the update request in the background
        if (!deviceAddress.startsWith("http://") && !deviceAddress.startsWith("https://")) {
          deviceAddress = "http://" + deviceAddress;
        }
        
        fetch(deviceAddress + "/system_update", { method: 'POST' })
          .then(response => {
            // We don't need to wait for a response or show errors
            console.log("System update request sent to device");
          })
          .catch(function(error) {
            console.error("Error sending system update request:", error);
            // Don't show an error message to the user
          });
      }
    );
  }
  
  function triggerBackup() {
    var deviceIndex = document.getElementById('advancedActionsModal').getAttribute('data-device-index');
    var deviceRow = document.querySelector('tr[data-index="' + deviceIndex + '"]');
    var deviceAddress = deviceRow.getAttribute('data-address');
    if (!deviceAddress) {
      showOverlayMessage("Error: Device address not found");
      return;
    }
    showConfirmOverlay(
      "This will create a backup of the device. This may take several minutes. Continue?",
      function() {
        // Show a brief message and close the modal immediately
        showOverlayMessage("Backup command sent. The download will start automatically.", 2000);
        closeAdvancedActionsModal();
        
        // Prepare the download URL
        if (!deviceAddress.startsWith("http://") && !deviceAddress.startsWith("https://")) {
          deviceAddress = "http://" + deviceAddress;
        }
        
        // Create a download link
        var a = document.createElement('a');
        a.href = deviceAddress + "/backup";
        a.download = "backup_" + new Date().toISOString().replace(/:/g, '-') + ".img.gz";
        document.body.appendChild(a);
        
        // Trigger the download after a short delay
        setTimeout(function() {
          a.click();
          document.body.removeChild(a);
        }, 2000);
      }
    );
  }
  
  function triggerAppUpdate() {
    var deviceIndex = document.getElementById('advancedActionsModal').getAttribute('data-device-index');
    var deviceRow = document.querySelector('tr[data-index="' + deviceIndex + '"]');
    var deviceAddress = deviceRow.getAttribute('data-address');
    if (!deviceAddress) {
      showOverlayMessage("Error: Device address not found");
      return;
    }
    showConfirmOverlay(
      "This will update the application on the device and reboot it. Continue?",
      function() {
        // Show a brief message and close the modal immediately
        showOverlayMessage("Update command sent. The device will update and reboot automatically.", 2000);
        closeAdvancedActionsModal();
        
        // Send the update request in the background
        if (!deviceAddress.startsWith("http://") && !deviceAddress.startsWith("https://")) {
          deviceAddress = "http://" + deviceAddress;
        }
        
        fetch(deviceAddress + "/update", { method: 'POST' })
          .then(response => {
            // We don't need to wait for a response or show errors
            console.log("Update request sent to device");
          })
          .catch(function(error) {
            console.error("Error sending update request:", error);
            // Don't show an error message to the user
          });
      }
    );
  }

  // Function to populate the CLIP model dropdown with downloaded models
  function populateDownloadedModels() {
    fetch("{{ url_for('settings.list_custom_models') }}")
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.status === "success") {
          var modelsGroup = document.getElementById('downloaded_models_group');
          // Clear existing options
          modelsGroup.innerHTML = '';
          
          if (data.models.length === 0) {
            var option = document.createElement('option');
            option.disabled = true;
            option.text = "No downloaded models";
            modelsGroup.appendChild(option);
          } else {
            // Add each model to the dropdown
            data.models.forEach(function(model) {
              var option = document.createElement('option');
              option.value = model.name;
              option.text = model.name;
              // Check if this model is currently selected
              if ("{{ config.clip_model if config and config.clip_model }}" === model.name) {
                option.selected = true;
              }
              modelsGroup.appendChild(option);
            });
          }
        }
      })
      .catch(function(error) {
        console.error("Error loading downloaded models:", error);
      });
  }

  document.addEventListener('DOMContentLoaded', function() {
      // Keep the dropdown menu functionality for backward compatibility
      const settingsNavItem = document.querySelector('.navbar-nav .nav-item:last-child');
      if (settingsNavItem) {
        // Create dropdown menu
        settingsNavItem.classList.add('dropdown');
        const settingsLink = settingsNavItem.querySelector('.nav-link');
        settingsLink.classList.add('dropdown-toggle');
        settingsLink.setAttribute('data-bs-toggle', 'dropdown');
        settingsLink.setAttribute('aria-expanded', 'false');
        
        // Create dropdown menu
        const dropdownMenu = document.createElement('ul');
        dropdownMenu.className = 'dropdown-menu dropdown-menu-end';
        
        // Add Settings link
        const settingsItem = document.createElement('li');
        const settingsItemLink = document.createElement('a');
        settingsItemLink.className = 'dropdown-item';
        settingsItemLink.href = "{{ url_for('settings.settings') }}";
        settingsItemLink.textContent = 'Device Settings';
        settingsItem.appendChild(settingsItemLink);
        dropdownMenu.appendChild(settingsItem);
        
        // Add Tagging Settings link
        const clipItem = document.createElement('li');
        const clipItemLink = document.createElement('a');
        clipItemLink.className = 'dropdown-item';
        clipItemLink.href = '#';
        clipItemLink.textContent = 'Tagging Settings';
        clipItemLink.addEventListener('click', function(e) {
          e.preventDefault();
          document.getElementById('clipSettingsModal').style.display = 'block';
        });
        clipItem.appendChild(clipItemLink);
        dropdownMenu.appendChild(clipItem);
        
        // Add dropdown menu to navbar
        settingsNavItem.appendChild(dropdownMenu);
      }
  
      // Make sure the direct button also works
      const openClipSettingsBtn = document.getElementById('openClipSettingsBtn');
      if (openClipSettingsBtn) {
        openClipSettingsBtn.addEventListener('click', function() {
          document.getElementById('clipSettingsModal').style.display = 'block';
        });
      }
      
      // Initialize Bootstrap tabs
      try {
        const triggerTabList = document.querySelectorAll('#clipSettingsTabs button');
        triggerTabList.forEach(triggerEl => {
          const tabTrigger = new bootstrap.Tab(triggerEl);
          
          triggerEl.addEventListener('click', event => {
            event.preventDefault();
            tabTrigger.show();
          });
        });
      } catch (e) {
        console.error("Error initializing tabs:", e);
      }
      
      // Populate downloaded models on page load
      populateDownloadedModels();
    
    var addNewDisplayBtn = document.getElementById('addNewDisplayBtn');
    if (addNewDisplayBtn) {
      addNewDisplayBtn.addEventListener('click', function() {
        document.getElementById('addDisplayModal').style.display = 'block';
      });
    }
    var addDisplayForm = document.getElementById('addDisplayForm');
    addDisplayForm.addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Check if color field is populated
      var colorField = document.getElementById('newColor');
      if (!colorField.value) {
        // If color is not set, set a default color
        var availableColors = ['#FF5733', '#33FF57', '#3357FF', '#F39C12', '#8E44AD', '#2ECC71', '#E74C3C'];
        var randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
        colorField.value = randomColor;
      }
      
      // Check if display name and resolution are populated
      var displayNameField = document.getElementById('newDisplayName');
      var resolutionField = document.getElementById('newResolution');
      
      if (!displayNameField.value) {
        displayNameField.value = "DefaultDisplay";
      }
      
      if (!resolutionField.value) {
        resolutionField.value = "800x600";
      }
      
      // Now submit the form
      addDisplayForm.submit();
    });
    document.getElementById('closeAddDisplayModal').addEventListener('click', function() {
      closeAddDisplayModal();
    });
    document.getElementById('closeEditDisplayModal').addEventListener('click', function() {
      closeEditDisplayModal();
    });
    document.getElementById('closeAdvancedActionsModal').addEventListener('click', function() {
      closeAdvancedActionsModal();
    });
    var clipSettingsBtn = document.getElementById('clipSettingsBtn');
    var clipSettingsModal = document.getElementById('clipSettingsModal');
    var closeClipSettingsModal = document.getElementById('closeClipSettingsModal');
    if (clipSettingsBtn) {
      clipSettingsBtn.addEventListener('click', function() {
        clipSettingsModal.style.display = 'block';
      });
    }
    if (closeClipSettingsModal) {
      closeClipSettingsModal.addEventListener('click', function() {
        window.closeClipSettingsModal();
      });
    }
    window.addEventListener('click', function(e) {
      if (e.target == clipSettingsModal) {
        window.closeClipSettingsModal();
      }
    });
  });

  function saveClipModel() {
    var clipModel = document.getElementById('clip_model').value;
    if (!clipModel) {
      showOverlayMessage("Please select a CLIP model");
      return;
    }
    var payload = {
      clip_model: clipModel
    };
    showOverlayMessage("Switching to model: " + clipModel + "...", 1500);
    fetch("{{ url_for('settings.update_clip_model') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        showOverlayMessage("CLIP model updated successfully to " + clipModel);
      } else {
        showOverlayMessage("Error updating CLIP model: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      showOverlayMessage("An error occurred while updating CLIP model.");
    });
  }

  function verifyClipModel() {
    fetch("{{ url_for('settings.verify_clip_model') }}")
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        showOverlayMessage(
          `<strong>Current CLIP Model:</strong> ${data.model_name}<br>` +
          `<span class="text-muted">This is the model that will be used for image tagging.</span><br><br>` +
          `<strong>Model Details:</strong><br>` +
          `• ViT-B-32: Fastest, less accurate<br>` +
          `• ViT-B-16: Balanced performance<br>` +
          `• ViT-L-14: Slowest, most accurate`
        );
      } else {
        showOverlayMessage("Error verifying CLIP model: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      showOverlayMessage("An error occurred while verifying CLIP model.");
    });
  }

  function saveMinTags() {
    var maxTags = document.getElementById('min_tags').value;
    if (!maxTags || isNaN(maxTags) || maxTags < 1) {
      showOverlayMessage("Please enter a valid number (minimum 1)");
      return;
    }
    var payload = {
      min_tags: parseInt(maxTags)
    };
    showOverlayMessage("Updating maximum tags setting...", 1500);
    fetch("{{ url_for('settings.update_clip_model') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        showOverlayMessage("Maximum tags setting updated successfully to " + maxTags);
      } else {
        showOverlayMessage("Error updating maximum tags setting: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      showOverlayMessage("An error occurred while updating maximum tags setting.");
    });
  }
  
  function saveSimilarityThreshold() {
    var threshold = document.getElementById('similarity_threshold').value;
    if (!threshold) {
      showOverlayMessage("Please select a relevance level");
      return;
    }
    
    var thresholdText = document.getElementById('similarity_threshold').options[document.getElementById('similarity_threshold').selectedIndex].text;
    thresholdText = thresholdText.split(' - ')[0]; // Get just the level name
    
    var payload = {
      similarity_threshold: threshold
    };
    
    showOverlayMessage("Updating tag relevance level...", 1500);
    fetch("{{ url_for('settings.update_clip_model') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        showOverlayMessage("Tag relevance level updated successfully to " + thresholdText);
      } else {
        showOverlayMessage("Error updating tag relevance level: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      showOverlayMessage("An error occurred while updating tag relevance level.");
    });
  }

  function testTagging() {
    const fileInput = document.getElementById('testImageFile');
    if (!fileInput.files || fileInput.files.length === 0) {
      showOverlayMessage("Please select an image file to test");
      return;
    }
    
    const file = fileInput.files[0];
    const formData = new FormData();
    formData.append('file', file);
    
    // Show loading state
    const resultDiv = document.getElementById('testTaggingResult');
    const contentDiv = document.getElementById('testTaggingContent');
    resultDiv.style.display = 'block';
    contentDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Processing image...</p></div>';
    
    fetch("{{ url_for('settings.test_tagging') }}", {
      method: 'POST',
      body: formData
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        let html = `
          <div class="mb-3">
            <strong>Model Used:</strong> ${data.model_used}
          </div>
          <div class="mb-3">
            <strong>Generated Tags:</strong><br>
            <ul class="list-group">
        `;
        
        // Add tags with their similarity scores
        data.tags_with_scores.forEach(function(tagInfo) {
          const tag = tagInfo.tag;
          const score = tagInfo.score;
          // Color code based on similarity score
          let badgeClass = "bg-danger";
          if (score >= 0.5) {
            badgeClass = "bg-success";
          } else if (score >= 0.3) {
            badgeClass = "bg-primary";
          } else if (score >= 0.2) {
            badgeClass = "bg-warning text-dark";
          }
          
          html += `<li class="list-group-item d-flex justify-content-between align-items-center">
            ${tag}
            <span class="badge ${badgeClass} rounded-pill">${score.toFixed(3)}</span>
          </li>`;
        });
        
        html += `
            </ul>
          </div>
          <div class="alert alert-info">
            <small>
              <strong>Tag Relevance Level:</strong> ${data.threshold_description}<br>
              <strong>Similarity Threshold:</strong> ${data.threshold.toFixed(2)}<br>
              <strong>Maximum Tags:</strong> ${data.max_tags}<br>
              <span class="text-muted">Only tags with similarity score ≥ ${data.threshold} are included in the final result.</span>
            </small>
          </div>
        `;
        
        contentDiv.innerHTML = html;
      } else {
        contentDiv.innerHTML = `<div class="alert alert-danger">${data.message || "Error processing image"}</div>`;
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      contentDiv.innerHTML = `<div class="alert alert-danger">An error occurred while processing the image.</div>`;
    });
  }

  function downloadCustomModel() {
    var modelName = document.getElementById('custom_model_name').value.trim();
    if (!modelName) {
      showOverlayMessage("Please enter a model name");
      return;
    }
    
    // Show the download progress container
    var progressContainer = document.getElementById('modelDownloadContainer');
    var progressBar = document.getElementById('modelDownloadProgress');
    var modelNameSpan = document.getElementById('modelDownloadName');
    
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    progressBar.textContent = '0%';
    modelNameSpan.textContent = modelName;
    
    // Start the download
    fetch("{{ url_for('settings.download_model') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model_name: modelName })
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        // Start polling for progress
        var taskId = data.task_id;
        var progressInterval = setInterval(function() {
          checkDownloadProgress(taskId, progressBar, progressInterval);
        }, 1000);
      } else {
        progressContainer.style.display = 'none';
        showOverlayMessage("Error starting download: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      progressContainer.style.display = 'none';
      showOverlayMessage("An error occurred while starting the download.");
    });
  }
  
  function checkDownloadProgress(taskId, progressBar, interval) {
    fetch("{{ url_for('settings.download_progress', task_id='') }}" + taskId)
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.status === "success") {
          var progress = data.progress;
          var percent = progress.progress;
          var status = progress.status;
          
          // Update the progress bar
          progressBar.style.width = percent + '%';
          progressBar.textContent = percent + '%';
          progressBar.setAttribute('aria-valuenow', percent);
          
          // Update status text with more details
          var statusText = "";
          if (status === "downloading") {
            statusText = `Downloading (${percent}%)`;
            if (progress.current_attempt) {
              statusText += `: ${progress.current_attempt}`;
            }
          } else if (status === "finalizing") {
            statusText = `Finalizing (${percent}%)`;
          } else if (status === "starting") {
            statusText = "Preparing download...";
          }
          
          // Show current attempt info if available
          document.getElementById('modelDownloadStatus').textContent = statusText;
          
          // If completed or error, stop polling
          if (status === "completed") {
            clearInterval(interval);
            // Update progress bar to success style
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add('bg-success');
            progressBar.textContent = "Download Complete!";
            
            // Show success message
            document.getElementById('modelDownloadStatus').innerHTML =
              '<span class="text-success"><i class="bi bi-check-circle-fill"></i> Model downloaded successfully!</span>';
            
            // Update the custom model info
            document.getElementById('custom_model_info').innerHTML =
              '<p class="mb-0"><strong>Current custom model:</strong> ' + progress.model_name + '</p>';
            
            // Refresh the dropdown to include the new model
            populateDownloadedModels();
            
            // Hide progress after a delay
            setTimeout(function() {
              document.getElementById('modelDownloadContainer').style.display = 'none';
            }, 3000);
            
            // Show a success message
            showOverlayMessage(`<div class="text-center">
              <i class="bi bi-check-circle-fill text-success fs-1"></i>
              <h5 class="mt-2">Model Downloaded Successfully!</h5>
              <p>The model "${progress.model_name}" is now available for use.</p>
            </div>`);
          } else if (status === "error") {
            clearInterval(interval);
            // Update progress bar to error style
            progressBar.classList.remove('progress-bar-animated');
            progressBar.classList.add('bg-danger');
            
            // Show error in status
            document.getElementById('modelDownloadStatus').innerHTML =
              '<span class="text-danger"><i class="bi bi-exclamation-triangle-fill"></i> ' +
              (progress.error || "Unknown error") + '</span>';
            
            // Hide progress after a delay
            setTimeout(function() {
              document.getElementById('modelDownloadContainer').style.display = 'none';
            }, 5000);
            
            // Show error message
            showOverlayMessage(`<div class="text-center">
              <i class="bi bi-exclamation-triangle-fill text-danger fs-1"></i>
              <h5 class="mt-2">Download Failed</h5>
              <p>${progress.error || "Unknown error"}</p>
              <p class="text-muted small">Try a different model or check the logs for more details.</p>
            </div>`);
          }
        } else {
          // If task not found, it might have completed and been removed
          clearInterval(interval);
          document.getElementById('modelDownloadContainer').style.display = 'none';
        }
      })
      .catch(function(error) {
        console.error("Error checking progress:", error);
        // Don't clear the interval on network errors, keep trying
      });
  }
  
  function saveRAMSettings() {
    var enableRAM = true; // Always enabled
    var ramModel = "ram_large"; // Always use the large model
    var ramMinConfidence;
    
    // Get confidence value from the global slider if available, otherwise from the hidden field
    if (document.getElementById('ram_min_confidence_global')) {
      ramMinConfidence = parseFloat(document.getElementById('ram_min_confidence_global').value);
      // Update the hidden field to keep them in sync
      document.getElementById('ram_min_confidence').value = ramMinConfidence;
    } else {
      ramMinConfidence = parseFloat(document.getElementById('ram_min_confidence').value);
    }
    
    var payload = {
      ram_enabled: enableRAM,
      ram_model: ramModel,
      ram_min_confidence: ramMinConfidence
    };
    
    fetch("{{ url_for('settings.update_ram_settings') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        showOverlayMessage("RAM model settings updated successfully");
      } else {
        showOverlayMessage("Error updating RAM settings: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      showOverlayMessage("An error occurred while updating RAM settings.");
    });
  }
  
  function downloadRAMModel() {
    var ramModel = document.getElementById('ram_model').value;
    
    // Show the download progress container
    var progressContainer = document.getElementById('modelDownloadContainer');
    var progressBar = document.getElementById('modelDownloadProgress');
    var modelNameSpan = document.getElementById('modelDownloadName');
    
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    progressBar.textContent = '0%';
    modelNameSpan.textContent = ramModel;
    
    // Start the download
    fetch("{{ url_for('settings.download_ram_model') }}", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model_name: ramModel })
    })
    .then(function(response) { return response.json(); })
    .then(function(data) {
      if (data.status === "success") {
        // Start polling for progress
        var taskId = data.task_id;
        var progressInterval = setInterval(function() {
          checkDownloadProgress(taskId, progressBar, progressInterval);
        }, 1000);
      } else {
        progressContainer.style.display = 'none';
        showOverlayMessage("Error starting download: " + data.message);
      }
    })
    .catch(function(error) {
      console.error("Error:", error);
      progressContainer.style.display = 'none';
      showOverlayMessage("An error occurred while starting the download.");
    });
  }
  
  // Function to filter models in the available models list
  function filterModels() {
    var input = document.getElementById('modelSearchInput');
    var filter = input.value.toUpperCase();
    var badges = document.querySelectorAll('.model-badge');
    var groups = document.querySelectorAll('.model-group');
    
    badges.forEach(function(badge) {
      var model = badge.getAttribute('data-model');
      if (model.toUpperCase().indexOf(filter) > -1) {
        badge.style.display = "";
      } else {
        badge.style.display = "none";
      }
    });
    
    // Show/hide groups based on whether they have any visible badges
    groups.forEach(function(group) {
      var visibleBadges = group.querySelectorAll('.model-badge[style="display: none;"]');
      var totalBadges = group.querySelectorAll('.model-badge');
      if (visibleBadges.length < totalBadges.length) {
        group.style.display = "";
      } else {
        group.style.display = "none";
      }
    });
  }
  
  function showAvailableModels() {
    fetch("{{ url_for('settings.list_available_models') }}")
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.status === "success") {
          var modelList = "<h4>Available Models</h4><p>These are the models that can be downloaded. Click on a model to select it.</p>";
          
          // Group models by type for better organization
          var modelGroups = {};
          data.models.forEach(function(model) {
            var prefix = model.split('-')[0];
            if (!modelGroups[prefix]) {
              modelGroups[prefix] = [];
            }
            modelGroups[prefix].push(model);
          });
          
          // Create a list with collapsible sections and search
          modelList += `
            <div class="mb-3">
              <input type="text" id="modelSearchInput" class="form-control" placeholder="Search models..." onkeyup="filterModels()">
            </div>
            <div id="modelListContainer" style='max-height: 500px; overflow-y: auto;'>
          `;
          
          // Sort prefixes alphabetically
          var sortedPrefixes = Object.keys(modelGroups).sort();
          
          for (var i = 0; i < sortedPrefixes.length; i++) {
            var prefix = sortedPrefixes[i];
            var models = modelGroups[prefix].sort(); // Sort models alphabetically
            
            modelList += `
              <div class="card mb-3 model-group" data-prefix="${prefix}">
                <div class="card-header" id="heading${prefix}">
                  <h5 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse${prefix}" aria-expanded="true" aria-controls="collapse${prefix}">
                      ${prefix} Models (${models.length})
                    </button>
                  </h5>
                </div>
                <div id="collapse${prefix}" class="collapse show" aria-labelledby="heading${prefix}">
                  <div class="card-body">
                    <div class="d-flex flex-wrap">
            `;
            
            models.forEach(function(model) {
              modelList += `<span class="badge bg-primary model-badge" style="cursor: pointer; margin: 5px; padding: 8px;" onclick="selectModel('${model}')" data-model="${model}">${model}</span>`;
            });
            
            modelList += `
                    </div>
                  </div>
                </div>
              </div>
            `;
          }
          
          modelList += "</div>";
          
          modelList += `
            <p class='text-muted mt-3'>
              <strong>Note:</strong> Not all models may be compatible. If a model fails to download, try another one.<br>
              Recommended models: ViT-B-32, ViT-B-16, RN50
            </p>
          `;
          
          showOverlayMessage(modelList);
          
          // Initialize collapse functionality
          var collapseBtns = document.querySelectorAll('[data-toggle="collapse"]');
          collapseBtns.forEach(function(btn) {
            btn.addEventListener('click', function() {
              var target = document.querySelector(btn.getAttribute('data-target'));
              if (target.classList.contains('show')) {
                target.classList.remove('show');
              } else {
                target.classList.add('show');
              }
            });
          });
          
        } else {
          showOverlayMessage("Error listing available models: " + data.message);
        }
      })
      .catch(function(error) {
        console.error("Error:", error);
        showOverlayMessage("An error occurred while listing available models.");
      });
  }
  
  function selectModel(model) {
    document.getElementById('custom_model_name').value = model;
    // Close any open overlay
    var overlays = document.getElementsByClassName('overlay-popup');
    if (overlays.length > 0) {
      overlays[0].remove();
    }
  }
  
  function deleteModel(modelName) {
    showConfirmOverlay(
      `Are you sure you want to delete the model "${modelName}"?`,
      function() {
        fetch("{{ url_for('settings.delete_model') }}", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model_name: modelName })
        })
        .then(function(response) { return response.json(); })
        .then(function(data) {
          if (data.status === "success") {
            // Check if this was the last model
            fetch("{{ url_for('settings.list_custom_models') }}")
              .then(function(response) { return response.json(); })
              .then(function(modelData) {
                if (modelData.status === "success") {
                  // Close any open overlays
                  var overlays = document.getElementsByClassName('overlay-popup');
                  for (var i = overlays.length - 1; i >= 0; i--) {
                    overlays[i].remove();
                  }
                  
                  // Show success message
                  showOverlayMessage("Model deleted successfully");
                  
                  // If there are still models, show the list
                  if (modelData.models.length > 0) {
                    listCustomModels();
                  }
                  
                  // Refresh the dropdown
                  populateDownloadedModels();
                }
              });
          } else {
            showOverlayMessage("Error deleting model: " + data.message);
          }
        })
        .catch(function(error) {
          console.error("Error:", error);
          showOverlayMessage("An error occurred while deleting the model.");
        });
      }
    );
  }

  function listCustomModels() {
    fetch("{{ url_for('settings.list_custom_models') }}")
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.status === "success") {
          if (data.models.length === 0) {
            showOverlayMessage("No custom models have been downloaded yet.");
            return;
          }
          
          var modelList = "<h4>Downloaded Models</h4><div class='list-group'>";
          data.models.forEach(function(model) {
            var downloadDate = new Date(model.download_date).toLocaleString();
            var pretrained = model.pretrained_tag ? ` (Tag: ${model.pretrained_tag})` : '';
            var variation = model.model_variation && model.model_variation !== model.name ? ` (Variation: ${model.model_variation})` : '';
            
            modelList += `
              <div class="list-group-item d-flex justify-content-between align-items-center">
                <div>
                  <strong>${model.name}</strong>
                  <small class="d-block text-muted">Downloaded: ${downloadDate}${pretrained}${variation}</small>
                </div>
                <button class="btn btn-sm btn-danger" onclick="deleteModel('${model.name}')">Delete</button>
              </div>
            `;
          });
          modelList += "</div>";
          
          showOverlayMessage(modelList);
        } else {
          showOverlayMessage("Error listing custom models: " + data.message);
        }
      })
      .catch(function(error) {
        console.error("Error:", error);
        showOverlayMessage("An error occurred while listing custom models.");
      });
  }
  
  function rerunAllTagging() {
    showConfirmOverlay(
      "<strong>Warning:</strong> This will rerun tagging on all images using the selected RAM model and will <span style='color: red;'>remove all existing tags</span>. The system will generate new tags based on your current settings.<br><br>This may take some time depending on the number of images. Continue?",
      function() {
        fetch("{{ url_for('settings.rerun_all_tagging') }}", {
          method: 'POST'
        })
        .then(function(response) { return response.json(); })
        .then(function(data) {
          if (data.status === "success") {
            showOverlayMessage("Tagging process started! This will run in the background.");
            document.getElementById('clipSettingsModal').style.display = 'none';
          } else {
            showOverlayMessage("Error starting tagging process: " + data.message);
          }
        })
        .catch(function(error) {
          console.error("Error:", error);
          showOverlayMessage("An error occurred while starting the tagging process.");
        });
      }
    );
  }

  function fetchDisplayInfo(mode) {
    return new Promise(function(resolve, reject) {
      if (mode === 'new') {
        var addressInput = document.getElementById('newAddress');
        var address = addressInput.value.trim();
        if (!address) {
          alert("Please enter the device address.");
          reject("No address provided");
          return;
        }
        // Create an AbortController for timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        fetch("/device_info?address=" + encodeURIComponent(address), {
          signal: controller.signal
        })
          .then(function(response) {
            if (!response.ok) {
              throw new Error("HTTP error " + response.status);
            }
            return response.json();
          })
          .then(function(data) {
            if (data.status === "ok") {
              document.getElementById('newDisplayName').value = data.info.display_name;
              document.getElementById('newResolution').value = data.info.resolution;
              var availableColors = ['#FF5733', '#33FF57', '#3357FF', '#F39C12', '#8E44AD', '#2ECC71', '#E74C3C'];
              var randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
              document.getElementById('newColor').value = randomColor;
              resolve();
            } else {
              alert("Error fetching display info: " + data.message + "; using default values.");
              document.getElementById('newDisplayName').value = "DefaultDisplay";
              document.getElementById('newResolution').value = "800x600";
              document.getElementById('newColor').value = "#FF5733";
              resolve();
            }
          })
          .catch(function(error) {
            console.error("Error fetching display info:", error);
            let errorMessage = "Error fetching display info";
            
            if (error.name === 'AbortError') {
              errorMessage += ": Request timed out";
            }
            
            alert(errorMessage + "; using default values.");
            document.getElementById('newDisplayName').value = "DefaultDisplay";
            document.getElementById('newResolution').value = "800x600";
            document.getElementById('newColor').value = "#FF5733";
            resolve();
          })
          .finally(() => {
            // Clear the timeout to prevent memory leaks
            clearTimeout(timeoutId);
          });
      } else if (mode === 'edit') {
        alert("Fetch Display Info for edit is not implemented yet.");
        resolve();
      }
    });
  }
</script>
{% endblock %}